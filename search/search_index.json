{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tsrc - managing groups of git repositories \u00b6 What it does \u00b6 tsrc is a command-line tool that helps you manage groups of git repositories. It works by listing the repositories in a file called manifest.yml that looks like this: repos : - dest : foo url : git@example.com:foo.git - dest : bar url : git@example.com:bar.git You can then use: tsrc init <manifest url> to create a workspace containing the foo and bar repository tsrc sync to synchronize all repos in the workspace. ... and many more commands. Run tsrc help to list them, or read the command line reference Tutorial \u00b6 Interested in using tsrc in your own organization? Proceed to the getting started tutorial ! Guides \u00b6 Once you've learn how to setup tsrc for your organization, feel free to read the following guides - tsrc supports a variety of use cases beyond just listing git repositories to be cloned or synchronized and are described here: Editing the manifest safely Editing workspace configuration Using groups Using several remotes Using fixed git references Performing file system operations Running a command for each repo in the workspace Using tsrc with continuous integration Reference \u00b6 Command line interface Sync algorithm Manifest configuration Workspace configuration Contributing \u00b6 Using the issue tracker Suggesting changes Code Manifesto Useful links \u00b6 FAQ Changelog","title":"Home"},{"location":"#tsrc_-_managing_groups_of_git_repositories","text":"","title":"tsrc - managing groups of git repositories"},{"location":"#what_it_does","text":"tsrc is a command-line tool that helps you manage groups of git repositories. It works by listing the repositories in a file called manifest.yml that looks like this: repos : - dest : foo url : git@example.com:foo.git - dest : bar url : git@example.com:bar.git You can then use: tsrc init <manifest url> to create a workspace containing the foo and bar repository tsrc sync to synchronize all repos in the workspace. ... and many more commands. Run tsrc help to list them, or read the command line reference","title":"What it does"},{"location":"#tutorial","text":"Interested in using tsrc in your own organization? Proceed to the getting started tutorial !","title":"Tutorial"},{"location":"#guides","text":"Once you've learn how to setup tsrc for your organization, feel free to read the following guides - tsrc supports a variety of use cases beyond just listing git repositories to be cloned or synchronized and are described here: Editing the manifest safely Editing workspace configuration Using groups Using several remotes Using fixed git references Performing file system operations Running a command for each repo in the workspace Using tsrc with continuous integration","title":"Guides"},{"location":"#reference","text":"Command line interface Sync algorithm Manifest configuration Workspace configuration","title":"Reference"},{"location":"#contributing","text":"Using the issue tracker Suggesting changes Code Manifesto","title":"Contributing"},{"location":"#useful_links","text":"FAQ Changelog","title":"Useful links"},{"location":"changelog/","text":"Changelog \u00b6 2.7.1 (2022-05-30) \u00b6 In addition to preserving the order repos are listed in the manifest, tsrc now makes sure repos included via groups are processed before the other repos. See #356 for details. Thanks to @raabf for the bug report and code review! 2.7.0 (2022-05-14) \u00b6 Show which git commands are run by default. tsrc init : fix order of operations - clone the local manifest before writing the workspace configuration. Fixes #344, where users could not run init a second time if the previous call failed. Bug report by @cgestes. tsrc init : do not assume the default branch of the manifest is master . Note that master is still hard-coded in a few places. See #347 for details. Breaking : When using -j 1 , do not sort repositories by lexical order of destination, but preserve the order in which they were specified in the manifest. Suggested by @raabf. 2.6.0 (2022-03-27) \u00b6 Allow to use python -m tsrc in addition to just tsrc Documentation updates Bump mypy 2.5.0 (2022-12-21) \u00b6 Highlights \u00b6 Bump minimum supported version to Python 3.7 . Introduce ignore_submodules repository option - Patch by Thomas Hiscock. When -j is not used, try getting the default jobs value from the TSRC_PARALLEL_JOBS environment variable. Patch by Marcin Jaworski. Other \u00b6 Bump mkdocs from 1.2.2 to 1.2.3 Bump pygit2 Bump linters (flake8, mypy, black) Remove dependency on attr 2.4.1 (2021-11-05) \u00b6 Ad more guides in the documentation Display absolute paths when performing file system operations tsrc sync now uses parallel jobs by default. Use -j1 to force sequential processing. Patch by @gdubicki 2.4.0 (2021-08-22) \u00b6 Highlights \u00b6 All of tsrc commands can now be run in parallel. Try for instance tsrc sync -j auto . tsrc foreach now sets a bunch of environment variables. This allows developers to add new behaviors to tsrc without having to change its source code. See the relevant guide for more information. Augment documentation with more use cases and examples (still a work in progress) Breaking changes \u00b6 Remove tsrc version - Use tsrc --version instead. The 'parallel' feature caused the output of some commands like foreach or log to change slightly. Hopefully tsrc output is now more consistent. Bug fixes \u00b6 Fix crash when running tsrc without any arguments Fix crash when trying to clone repositories in some rare corner cases (like the destination existing but not being a directory) Internal changes \u00b6 Make all tsrc imports consistent Fix error when calling repr on tsrc Errors. 2.3.1 (2021-06-28) \u00b6 Bug fixes and small improvements \u00b6 Fix #268: tsrc apply-manifest now performs file system operation Always display workspace path at the beginning of any action Skip \"performing file system operations\" message if there is no work to be done Internal changes \u00b6 Bump linters and formatters ( black , mypy , isort ...) Use copier to simplify maintenance of tools configuration 2.3.0 (2021-05-31) \u00b6 Repo selection \u00b6 Added -r (regex) and -i (inverse regex) params for filtering repos. Patch by @xzr Add support for submodules \u00b6 tsrc calls git clone with --recurse-submodules when adding missing repositories tsrc calls git submodule update --init --recursive when updating repositories Misc \u00b6 Remove codecov usage Rename default branch to main . 2.2.1 (2021-04-10) \u00b6 Project has been moved from TankerHQ organization to dmerejkowsky . New urls are: github.com/dmerejkowsky/tsrc for the git repository dmerejkowsky.github.io/tsrc for the documentation Add CI jobs to check this project also works with Python 3.9 Drop Path Pie dependency Minor internal fixes Add more URLs in the metadata (and pypi.org project page) 2.2.0 (2020-07-17) \u00b6 Add symlink support \u00b6 tsrc sync and tsrc init can now create symlinks as specified in the manifest file: repos : - url : git@gitlab.local:proj1/app dest : app symlink : - source : app/some_file target : ../some_file In this case, a symlink will be created from <workspace>/app/some_file to <workspace>/some_file . (both source and target keys are relative to the repository's destination). Changes related to groups \u00b6 log, status, and sync all learned about the --group option and the --all-cloned options foreach: remove the --groups-from-config options since this is now the default behavior Misc \u00b6 Rework FAQ Run black in lint.sh Fix formatting of some messages Update code manifesto to suggest using docstrings in tests 2.1.0 (2020-05-27) \u00b6 Breaking changes \u00b6 Change in manifest syntax \u00b6 It was discovered that the manifest syntax was confusing for newcomers, so we decided to update it. In particular, the src key meant both a relative path in the workspace when used in the repo config, and a relative path in the a repository when using in the repo.copy config. Starting with this release, repo.src becomes repo.dest and repo.copy.src becomes repo.copy.file . # Before (tsrc < 2.1.0) repos : url : \"https://acme.corp/foo\" src : foo copy : src : some-file dest : some-file # After (tsrc >= 2.1.0) repos : url : \"https://acme.corp/foo\" dest : foo copy : file : some-file dest : some-file This should make it clearer what tsrc does because: dest now always refers to a relative path in the workspace (both in repo and copy ). By using repo.copy.file it's obvious that tsrc only supports copying files, not directories. Supported Python versions \u00b6 Drop support for Python 3.5 New features \u00b6 tsrc init learned a -r, --remote option that pins the remote with the given name as the only remote to be used for cloning and syncing. tsrc expects this remote to be present in the manifest for all repositories. This is useful if you use the same workspace in different physical locations, and one of the remotes is behind a VPN for instance. Patch by @tronje. Bug fixes \u00b6 Fix #217 : Preserves file attributes during the copy statements in repos Other \u00b6 The whole test suite now runs without errors on Windows - and Windows support is now part of the GitHub actions checks. The tests now run faster and with more readable output (this was done by using libgit2 instead of running git commands in the tests helpers). Add a scheduled GitHub action to run safety Remove usage of deprecated API of the path library. Run tests and linters for external pull requests too. v2.0.0 - (2020-04-06) \u00b6 Remove the tsrc push command and all review automation features. Please use hub , lab , or repo instead. See #207 for the discussion leading to this removal. Implement small improvements on tsrc output messages. Add tsrc apply-manifest , to apply changes in a manifest file locally, without having to make a commit and push to a server first. v1.0.3 - (2020-02-05) \u00b6 Use poetry for dependency management and packaging. v1.0.2 - (2020-01-29) \u00b6 Fix python_requires value in project metadata v1.0.1 - (2020-01-21) \u00b6 Fix #196: Do not attempt file copies for non-cloned repositories when using tsrc init with a list of groups. v1.0.0 - (2020-01-09) \u00b6 Starting the new year with a stable release, at last! Revamp group UX \u00b6 The changes below in the configuration file and command line syntax allow for better UX regarding groups. See the corresponding milestone for the full list. New configuration file \u00b6 Previously, tsrc stored its permanent configuration in .tsrc/manifest.yml and the file was not supposed to be edited by hand. Instead, users could use tsrc init to modify it, for instance with the --branch argument. Starting with this release, the command tsrc init can only be run once per workspace, and you must edit the .tsrc/config.yml file instead. Changes in command line syntax \u00b6 tsrc init : remove --file option. tsrc foreach : instead of repeating the --group option, you can use --groups with a list of groups: # before tsrc init --group foo --group bar # after tsrc init --groups foo bar tsrc init learned a --clone-all-repos option to clone all repositories from the manifest, regardless of the groups. Fix #181 Remove --file option from tsrc init . tsrc foreach learned a --groups-from-config option to use the groups configured in the workspace. Fix #178, #179. tsrc push learned a -o, --origin option to specify a remote name different from \"origin\". Fix #170 Other fixes \u00b6 Try and check that GitLab installation support required features before using them - typically, using tsrc push --approvers on GitLab Community Edition. (#165) reported by @irizzant. Switch to GitHub actions for running tests and linters. Also, publish documentation automatically when something is pushed to the master branch. tsrc status : add information when local branch does not match manifest configuration. (#190). Feature suggested by @janjachnick v0.9.2 - (2019-09-30) \u00b6 Additional bug fix for #165 - the fix in 0.9.1 was incomplete Improve error message when trying to use non-supported GitLab features (like using tsrc push --reviewer on GitLab Community Edition) v0.9.1 - (2019-09-23) \u00b6 Improve error message when tsrc foreach fails to start the process. Suggested by @dlewis-ald in #163 Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165 v0.9.0 - (2019-08-13) \u00b6 Add support for GitHub Enterprise: patch by @sdavids13. Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the tsrc configuration file. Fix #158 Fix crash when running tsrc status on a workspace with missing repositories (#160) - reported by @blastrock v0.8.0 - (2019-08-12) \u00b6 Implement tsrc sync --force . Currently all it does is running git fetch --force on all repositories. Use with caution. See #152 for details. v0.7.1 - (2019-08-02) \u00b6 Fix crash in tsrc sync when the repo configuration in the manifest contained neither an URL nor a remote. tsrc now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86) v0.7.0 (2019-07-08) \u00b6 Add a --file option to tsrc init so that manifest can be read from a custom path in the file system Remove support for Python 3.4 Switch from xdg to pyxdg Format the code with black v0.6.6 (2019-04-02) \u00b6 Remove raw HTML from README.rst v0.6.5 (2019-04-0) \u00b6 Use codecov.io to measure coverage Prettify README v0.6.4 (2019-01-07) \u00b6 Remove support for Python 3.3. Use new and shiny cli-ui package instead of old python-cli-ui . v0.6.3 (2018-11-04) \u00b6 GitHub organization is now TankerHQ We now use dmenv for dependencies management v0.6.2 (2018-10-19) \u00b6 Fix crash when using tsrc push on a GitHub repository for the first time. v0.6.1 (2018-10-10) \u00b6 Fix weird output when configuring remotes. v0.6.0 (2018-10-09) \u00b6 Add support for multiple remotes \u00b6 # still valid (implicit 'origin' remote) src : foo url : git@github.com/foo # also valid (two explicit remotes) src : foo remotes : - { name : origin , url : git@github.com : john/foo } - { name : upstream , url : git@github.com : foo/foo } # not valid (ambiguous) src : foo url : git@github.com:john/foo remotes : - { name : upstream , url : git@github.com : foo/foo } Thanks @tst2005 and @cgestes for their help with the configuration format. tsrc foreach \u00b6 tsrc foreach : add a --group option to select the repositories to run the command on. Fix #40 Other fixes \u00b6 Fix #113 : do not hide branch when showing tag status. Add support for Python 3.7 v0.5.0 (2018-08-14) \u00b6 Add support for setting approvers with the -r,--approvers option in tsrc push (GitLab Enterprise Edition only). v0.4.1 (2018-04-27) \u00b6 Fixed regression: tsrc push was no longer able to create a merge request on GitLab if --target was not set. v0.4.0 (2018-04-26) \u00b6 Highlights \u00b6 Preliminary GitHub support tsrc push : new features and bug fixes Improved fixed reference handling Support for shallow clones See below for the details. Preliminary GitHub support \u00b6 Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using tsrc from a repository which has a URL starting with git@github.com . tsrc will prompt you once for your login and password and then store an API token. Afterwards, you'll be able to use tsrc push to: Create a pull request (or update it if it already exists) Assign people to the request (with the -a/--assignee option) Request reviewers (with the --reviewers option) Merge the pull request (with the --merge option) This change has no impact if you were already using GitLab . tsrc push : new features and bug fixes \u00b6 Add --close option. Breaking change : -m/--message option is gone, use --title instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title , so it had to be renamed. Do not assume local and remote tracking branch have the same name. Allow using tsrc push <local>:<remote> to explicitly specify local and remote branch names. Fix bugs when target is not specified on the command line. See this commit for details. Fix missing merge requests in tsrc push (see issue #80 ). Patch by @maximerety. Improve fixed reference handling \u00b6 Breaking change : Instead of using fixed_ref in the manifest, you should now use tag or sha1 : old : repos : - src : git@example.com/foo fixed_ref : 42a70 new : repos: - src: git@example.com/foo tag: v0.1 See the dedicated section about manifest format and the #57 pull request discussion for the details. This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1. Support for shallow clones \u00b6 To save time and space, you can use tsrc init --shallow to only have shallow clones in your workspace. Note that due to limitations in git itself, the shallow option cannot be used with a fixed SHA1. If you need this, prefer using a tag instead. Misc \u00b6 Organization TankerApp was renamed to TankerHQ . New urls are: github.com/TankerHQ/tsrc for the git repository TankerHQ.github.io/tsrc for the documentation We now use pipenv for dependency handling. v0.3.2 (2017-11-02) \u00b6 Improve tsrc status to handle tags. Patch by @arnaudgelas. Fix crash when running tsrc version . v0.3.1 (2017-10-06) \u00b6 Improve tsrc status output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas. v0.3.0 (2017-09-22) \u00b6 Breaking change : Add support for groups (#30). Reported by @arnaudgelas. See the dedicated section about manifest format for details. Upgrading from v0.2.4 : To upgrade from an older version of tsrc , you should re-run tsrc init with the correct url: # Check manifest URL: $ cd <workspace>/.tsrc/manifest $ git remote get-url origin # Note the url, for instance ssh://git@example.com:manifest.git $ cd <workspace> $ tsrc init <manifest-url> This is required to create the <workspace>/.tsrc/manifest.yml file which is later used by tsrc sync and other commands. v0.2.4 (2017-07-13) \u00b6 tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas v0.2.3 (2017-09-01) \u00b6 Split user interface functionality into its own project: python-cli-ui . Add --quiet and --color global options. v0.2.2 (2017-08-22) \u00b6 Bug fix release. tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes v0.2.1 (2017-08-10) \u00b6 Packaging fixes. v0.2.0 (2017-08-09) \u00b6 Support for specifying custom branches in the manifest Support for specifying fixed refs (tags or hashes) in the manifest New syntax is: repos : - src : foo url : git@gitlab.com:proj/foo branch : next - src : bar url : git@gitlab.com:proj/bar branch : master fixed_ref : v0.1 Note that branch is still required. You can now skip the dest part of the copy section if src and dest are equal: copy : - src:foo # same thing as copy : - src : foo dest : foo v0.1.4 (2017-08-04) \u00b6 Support for Python 3.3, 3.4, 3.5 and 3.6 v0.1.1 (2017-08-02) \u00b6 First public release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#271_2022-05-30","text":"In addition to preserving the order repos are listed in the manifest, tsrc now makes sure repos included via groups are processed before the other repos. See #356 for details. Thanks to @raabf for the bug report and code review!","title":"2.7.1 (2022-05-30)"},{"location":"changelog/#270_2022-05-14","text":"Show which git commands are run by default. tsrc init : fix order of operations - clone the local manifest before writing the workspace configuration. Fixes #344, where users could not run init a second time if the previous call failed. Bug report by @cgestes. tsrc init : do not assume the default branch of the manifest is master . Note that master is still hard-coded in a few places. See #347 for details. Breaking : When using -j 1 , do not sort repositories by lexical order of destination, but preserve the order in which they were specified in the manifest. Suggested by @raabf.","title":"2.7.0 (2022-05-14)"},{"location":"changelog/#260_2022-03-27","text":"Allow to use python -m tsrc in addition to just tsrc Documentation updates Bump mypy","title":"2.6.0 (2022-03-27)"},{"location":"changelog/#250_2022-12-21","text":"","title":"2.5.0 (2022-12-21)"},{"location":"changelog/#highlights","text":"Bump minimum supported version to Python 3.7 . Introduce ignore_submodules repository option - Patch by Thomas Hiscock. When -j is not used, try getting the default jobs value from the TSRC_PARALLEL_JOBS environment variable. Patch by Marcin Jaworski.","title":"Highlights"},{"location":"changelog/#other","text":"Bump mkdocs from 1.2.2 to 1.2.3 Bump pygit2 Bump linters (flake8, mypy, black) Remove dependency on attr","title":"Other"},{"location":"changelog/#241_2021-11-05","text":"Ad more guides in the documentation Display absolute paths when performing file system operations tsrc sync now uses parallel jobs by default. Use -j1 to force sequential processing. Patch by @gdubicki","title":"2.4.1 (2021-11-05)"},{"location":"changelog/#240_2021-08-22","text":"","title":"2.4.0 (2021-08-22)"},{"location":"changelog/#highlights_1","text":"All of tsrc commands can now be run in parallel. Try for instance tsrc sync -j auto . tsrc foreach now sets a bunch of environment variables. This allows developers to add new behaviors to tsrc without having to change its source code. See the relevant guide for more information. Augment documentation with more use cases and examples (still a work in progress)","title":"Highlights"},{"location":"changelog/#breaking_changes","text":"Remove tsrc version - Use tsrc --version instead. The 'parallel' feature caused the output of some commands like foreach or log to change slightly. Hopefully tsrc output is now more consistent.","title":"Breaking changes"},{"location":"changelog/#bug_fixes","text":"Fix crash when running tsrc without any arguments Fix crash when trying to clone repositories in some rare corner cases (like the destination existing but not being a directory)","title":"Bug fixes"},{"location":"changelog/#internal_changes","text":"Make all tsrc imports consistent Fix error when calling repr on tsrc Errors.","title":"Internal changes"},{"location":"changelog/#231_2021-06-28","text":"","title":"2.3.1 (2021-06-28)"},{"location":"changelog/#bug_fixes_and_small_improvements","text":"Fix #268: tsrc apply-manifest now performs file system operation Always display workspace path at the beginning of any action Skip \"performing file system operations\" message if there is no work to be done","title":"Bug fixes and small improvements"},{"location":"changelog/#internal_changes_1","text":"Bump linters and formatters ( black , mypy , isort ...) Use copier to simplify maintenance of tools configuration","title":"Internal changes"},{"location":"changelog/#230_2021-05-31","text":"","title":"2.3.0 (2021-05-31)"},{"location":"changelog/#repo_selection","text":"Added -r (regex) and -i (inverse regex) params for filtering repos. Patch by @xzr","title":"Repo selection"},{"location":"changelog/#add_support_for_submodules","text":"tsrc calls git clone with --recurse-submodules when adding missing repositories tsrc calls git submodule update --init --recursive when updating repositories","title":"Add support for submodules"},{"location":"changelog/#misc","text":"Remove codecov usage Rename default branch to main .","title":"Misc"},{"location":"changelog/#221_2021-04-10","text":"Project has been moved from TankerHQ organization to dmerejkowsky . New urls are: github.com/dmerejkowsky/tsrc for the git repository dmerejkowsky.github.io/tsrc for the documentation Add CI jobs to check this project also works with Python 3.9 Drop Path Pie dependency Minor internal fixes Add more URLs in the metadata (and pypi.org project page)","title":"2.2.1 (2021-04-10)"},{"location":"changelog/#220_2020-07-17","text":"","title":"2.2.0 (2020-07-17)"},{"location":"changelog/#add_symlink_support","text":"tsrc sync and tsrc init can now create symlinks as specified in the manifest file: repos : - url : git@gitlab.local:proj1/app dest : app symlink : - source : app/some_file target : ../some_file In this case, a symlink will be created from <workspace>/app/some_file to <workspace>/some_file . (both source and target keys are relative to the repository's destination).","title":"Add symlink support"},{"location":"changelog/#changes_related_to_groups","text":"log, status, and sync all learned about the --group option and the --all-cloned options foreach: remove the --groups-from-config options since this is now the default behavior","title":"Changes related to groups"},{"location":"changelog/#misc_1","text":"Rework FAQ Run black in lint.sh Fix formatting of some messages Update code manifesto to suggest using docstrings in tests","title":"Misc"},{"location":"changelog/#210_2020-05-27","text":"","title":"2.1.0 (2020-05-27)"},{"location":"changelog/#breaking_changes_1","text":"","title":"Breaking changes"},{"location":"changelog/#change_in_manifest_syntax","text":"It was discovered that the manifest syntax was confusing for newcomers, so we decided to update it. In particular, the src key meant both a relative path in the workspace when used in the repo config, and a relative path in the a repository when using in the repo.copy config. Starting with this release, repo.src becomes repo.dest and repo.copy.src becomes repo.copy.file . # Before (tsrc < 2.1.0) repos : url : \"https://acme.corp/foo\" src : foo copy : src : some-file dest : some-file # After (tsrc >= 2.1.0) repos : url : \"https://acme.corp/foo\" dest : foo copy : file : some-file dest : some-file This should make it clearer what tsrc does because: dest now always refers to a relative path in the workspace (both in repo and copy ). By using repo.copy.file it's obvious that tsrc only supports copying files, not directories.","title":"Change in manifest syntax"},{"location":"changelog/#supported_python_versions","text":"Drop support for Python 3.5","title":"Supported Python versions"},{"location":"changelog/#new_features","text":"tsrc init learned a -r, --remote option that pins the remote with the given name as the only remote to be used for cloning and syncing. tsrc expects this remote to be present in the manifest for all repositories. This is useful if you use the same workspace in different physical locations, and one of the remotes is behind a VPN for instance. Patch by @tronje.","title":"New features"},{"location":"changelog/#bug_fixes_1","text":"Fix #217 : Preserves file attributes during the copy statements in repos","title":"Bug fixes"},{"location":"changelog/#other_1","text":"The whole test suite now runs without errors on Windows - and Windows support is now part of the GitHub actions checks. The tests now run faster and with more readable output (this was done by using libgit2 instead of running git commands in the tests helpers). Add a scheduled GitHub action to run safety Remove usage of deprecated API of the path library. Run tests and linters for external pull requests too.","title":"Other"},{"location":"changelog/#v200_-_2020-04-06","text":"Remove the tsrc push command and all review automation features. Please use hub , lab , or repo instead. See #207 for the discussion leading to this removal. Implement small improvements on tsrc output messages. Add tsrc apply-manifest , to apply changes in a manifest file locally, without having to make a commit and push to a server first.","title":"v2.0.0 - (2020-04-06)"},{"location":"changelog/#v103_-_2020-02-05","text":"Use poetry for dependency management and packaging.","title":"v1.0.3 - (2020-02-05)"},{"location":"changelog/#v102_-_2020-01-29","text":"Fix python_requires value in project metadata","title":"v1.0.2 - (2020-01-29)"},{"location":"changelog/#v101_-_2020-01-21","text":"Fix #196: Do not attempt file copies for non-cloned repositories when using tsrc init with a list of groups.","title":"v1.0.1 - (2020-01-21)"},{"location":"changelog/#v100_-_2020-01-09","text":"Starting the new year with a stable release, at last!","title":"v1.0.0 - (2020-01-09)"},{"location":"changelog/#revamp_group_ux","text":"The changes below in the configuration file and command line syntax allow for better UX regarding groups. See the corresponding milestone for the full list.","title":"Revamp group UX"},{"location":"changelog/#new_configuration_file","text":"Previously, tsrc stored its permanent configuration in .tsrc/manifest.yml and the file was not supposed to be edited by hand. Instead, users could use tsrc init to modify it, for instance with the --branch argument. Starting with this release, the command tsrc init can only be run once per workspace, and you must edit the .tsrc/config.yml file instead.","title":"New configuration file"},{"location":"changelog/#changes_in_command_line_syntax","text":"tsrc init : remove --file option. tsrc foreach : instead of repeating the --group option, you can use --groups with a list of groups: # before tsrc init --group foo --group bar # after tsrc init --groups foo bar tsrc init learned a --clone-all-repos option to clone all repositories from the manifest, regardless of the groups. Fix #181 Remove --file option from tsrc init . tsrc foreach learned a --groups-from-config option to use the groups configured in the workspace. Fix #178, #179. tsrc push learned a -o, --origin option to specify a remote name different from \"origin\". Fix #170","title":"Changes in command line syntax"},{"location":"changelog/#other_fixes","text":"Try and check that GitLab installation support required features before using them - typically, using tsrc push --approvers on GitLab Community Edition. (#165) reported by @irizzant. Switch to GitHub actions for running tests and linters. Also, publish documentation automatically when something is pushed to the master branch. tsrc status : add information when local branch does not match manifest configuration. (#190). Feature suggested by @janjachnick","title":"Other fixes"},{"location":"changelog/#v092_-_2019-09-30","text":"Additional bug fix for #165 - the fix in 0.9.1 was incomplete Improve error message when trying to use non-supported GitLab features (like using tsrc push --reviewer on GitLab Community Edition)","title":"v0.9.2 - (2019-09-30)"},{"location":"changelog/#v091_-_2019-09-23","text":"Improve error message when tsrc foreach fails to start the process. Suggested by @dlewis-ald in #163 Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165","title":"v0.9.1 - (2019-09-23)"},{"location":"changelog/#v090_-_2019-08-13","text":"Add support for GitHub Enterprise: patch by @sdavids13. Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the tsrc configuration file. Fix #158 Fix crash when running tsrc status on a workspace with missing repositories (#160) - reported by @blastrock","title":"v0.9.0 - (2019-08-13)"},{"location":"changelog/#v080_-_2019-08-12","text":"Implement tsrc sync --force . Currently all it does is running git fetch --force on all repositories. Use with caution. See #152 for details.","title":"v0.8.0 - (2019-08-12)"},{"location":"changelog/#v071_-_2019-08-02","text":"Fix crash in tsrc sync when the repo configuration in the manifest contained neither an URL nor a remote. tsrc now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86)","title":"v0.7.1 - (2019-08-02)"},{"location":"changelog/#v070_2019-07-08","text":"Add a --file option to tsrc init so that manifest can be read from a custom path in the file system Remove support for Python 3.4 Switch from xdg to pyxdg Format the code with black","title":"v0.7.0 (2019-07-08)"},{"location":"changelog/#v066_2019-04-02","text":"Remove raw HTML from README.rst","title":"v0.6.6 (2019-04-02)"},{"location":"changelog/#v065_2019-04-0","text":"Use codecov.io to measure coverage Prettify README","title":"v0.6.5 (2019-04-0)"},{"location":"changelog/#v064_2019-01-07","text":"Remove support for Python 3.3. Use new and shiny cli-ui package instead of old python-cli-ui .","title":"v0.6.4 (2019-01-07)"},{"location":"changelog/#v063_2018-11-04","text":"GitHub organization is now TankerHQ We now use dmenv for dependencies management","title":"v0.6.3 (2018-11-04)"},{"location":"changelog/#v062_2018-10-19","text":"Fix crash when using tsrc push on a GitHub repository for the first time.","title":"v0.6.2 (2018-10-19)"},{"location":"changelog/#v061_2018-10-10","text":"Fix weird output when configuring remotes.","title":"v0.6.1 (2018-10-10)"},{"location":"changelog/#v060_2018-10-09","text":"","title":"v0.6.0 (2018-10-09)"},{"location":"changelog/#add_support_for_multiple_remotes","text":"# still valid (implicit 'origin' remote) src : foo url : git@github.com/foo # also valid (two explicit remotes) src : foo remotes : - { name : origin , url : git@github.com : john/foo } - { name : upstream , url : git@github.com : foo/foo } # not valid (ambiguous) src : foo url : git@github.com:john/foo remotes : - { name : upstream , url : git@github.com : foo/foo } Thanks @tst2005 and @cgestes for their help with the configuration format.","title":"Add support for multiple remotes"},{"location":"changelog/#tsrc_foreach","text":"tsrc foreach : add a --group option to select the repositories to run the command on. Fix #40","title":"tsrc foreach"},{"location":"changelog/#other_fixes_1","text":"Fix #113 : do not hide branch when showing tag status. Add support for Python 3.7","title":"Other fixes"},{"location":"changelog/#v050_2018-08-14","text":"Add support for setting approvers with the -r,--approvers option in tsrc push (GitLab Enterprise Edition only).","title":"v0.5.0 (2018-08-14)"},{"location":"changelog/#v041_2018-04-27","text":"Fixed regression: tsrc push was no longer able to create a merge request on GitLab if --target was not set.","title":"v0.4.1 (2018-04-27)"},{"location":"changelog/#v040_2018-04-26","text":"","title":"v0.4.0 (2018-04-26)"},{"location":"changelog/#highlights_2","text":"Preliminary GitHub support tsrc push : new features and bug fixes Improved fixed reference handling Support for shallow clones See below for the details.","title":"Highlights"},{"location":"changelog/#preliminary_github_support","text":"Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using tsrc from a repository which has a URL starting with git@github.com . tsrc will prompt you once for your login and password and then store an API token. Afterwards, you'll be able to use tsrc push to: Create a pull request (or update it if it already exists) Assign people to the request (with the -a/--assignee option) Request reviewers (with the --reviewers option) Merge the pull request (with the --merge option) This change has no impact if you were already using GitLab .","title":"Preliminary GitHub support"},{"location":"changelog/#tsrc_push_new_features_and_bug_fixes","text":"Add --close option. Breaking change : -m/--message option is gone, use --title instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title , so it had to be renamed. Do not assume local and remote tracking branch have the same name. Allow using tsrc push <local>:<remote> to explicitly specify local and remote branch names. Fix bugs when target is not specified on the command line. See this commit for details. Fix missing merge requests in tsrc push (see issue #80 ). Patch by @maximerety.","title":"tsrc push: new features and bug fixes"},{"location":"changelog/#improve_fixed_reference_handling","text":"Breaking change : Instead of using fixed_ref in the manifest, you should now use tag or sha1 : old : repos : - src : git@example.com/foo fixed_ref : 42a70 new : repos: - src: git@example.com/foo tag: v0.1 See the dedicated section about manifest format and the #57 pull request discussion for the details. This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1.","title":"Improve fixed reference handling"},{"location":"changelog/#support_for_shallow_clones","text":"To save time and space, you can use tsrc init --shallow to only have shallow clones in your workspace. Note that due to limitations in git itself, the shallow option cannot be used with a fixed SHA1. If you need this, prefer using a tag instead.","title":"Support for shallow clones"},{"location":"changelog/#misc_2","text":"Organization TankerApp was renamed to TankerHQ . New urls are: github.com/TankerHQ/tsrc for the git repository TankerHQ.github.io/tsrc for the documentation We now use pipenv for dependency handling.","title":"Misc"},{"location":"changelog/#v032_2017-11-02","text":"Improve tsrc status to handle tags. Patch by @arnaudgelas. Fix crash when running tsrc version .","title":"v0.3.2 (2017-11-02)"},{"location":"changelog/#v031_2017-10-06","text":"Improve tsrc status output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas.","title":"v0.3.1 (2017-10-06)"},{"location":"changelog/#v030_2017-09-22","text":"Breaking change : Add support for groups (#30). Reported by @arnaudgelas. See the dedicated section about manifest format for details. Upgrading from v0.2.4 : To upgrade from an older version of tsrc , you should re-run tsrc init with the correct url: # Check manifest URL: $ cd <workspace>/.tsrc/manifest $ git remote get-url origin # Note the url, for instance ssh://git@example.com:manifest.git $ cd <workspace> $ tsrc init <manifest-url> This is required to create the <workspace>/.tsrc/manifest.yml file which is later used by tsrc sync and other commands.","title":"v0.3.0 (2017-09-22)"},{"location":"changelog/#v024_2017-07-13","text":"tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas","title":"v0.2.4 (2017-07-13)"},{"location":"changelog/#v023_2017-09-01","text":"Split user interface functionality into its own project: python-cli-ui . Add --quiet and --color global options.","title":"v0.2.3 (2017-09-01)"},{"location":"changelog/#v022_2017-08-22","text":"Bug fix release. tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes","title":"v0.2.2 (2017-08-22)"},{"location":"changelog/#v021_2017-08-10","text":"Packaging fixes.","title":"v0.2.1 (2017-08-10)"},{"location":"changelog/#v020_2017-08-09","text":"Support for specifying custom branches in the manifest Support for specifying fixed refs (tags or hashes) in the manifest New syntax is: repos : - src : foo url : git@gitlab.com:proj/foo branch : next - src : bar url : git@gitlab.com:proj/bar branch : master fixed_ref : v0.1 Note that branch is still required. You can now skip the dest part of the copy section if src and dest are equal: copy : - src:foo # same thing as copy : - src : foo dest : foo","title":"v0.2.0 (2017-08-09)"},{"location":"changelog/#v014_2017-08-04","text":"Support for Python 3.3, 3.4, 3.5 and 3.6","title":"v0.1.4 (2017-08-04)"},{"location":"changelog/#v011_2017-08-02","text":"First public release","title":"v0.1.1 (2017-08-02)"},{"location":"code-manifesto/","text":"Code Manifesto \u00b6 Basics \u00b6 We use black to enforce a coding style matching PEP8 . In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set core.autocrlf to true in your git config file.) Pet peeves \u00b6 Prefer double quotes for string literals: # Yes def bar (): \"\"\" bar stuff \"\"\" a = \"foo\" # No def bar (): ''' bar stuff ''' a = 'foo' # Exception my_str = 'It contains some \"quotes\" inside' Use the fact that empty data structures are falsy: # Yes if not errors : ... # No if len ( errors ) == 0 : ... Avoid using double negatives: # Yes def make_coffee ( sugar = False ): if sugar : print ( \"with sugar\" ) # No def make_coffee ( without_sugar = True ): if not without_sugar : print ( \"with sugar\" ) Prefer using \"f-strings\" if possible, + may also work in some contexts. # Yes message = f \"Welcome { name } !\" # No message = \"Welcome, {} !\" . format ( name ) message = \"Welcome, %s !\" % name message = \"Welcome, \" + name + \"!\" # Okayish with_ext = name + \".txt\" Use textwrap.dedent() to build nice-looking multi-lines strings: # Yes def foo (): long_message = textwrap . dedent ( \"\"\" \\ first line second line third line\"\"\" ) # No def foo (): long_message = \"\"\" \\ first line second line third line \"\"\" Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory) # Yes ok , mess = run_command () for test_result in test_results : outcome , message = res # No foo , bar = False , \"\" class Foo : self . bar , self . baz = None , True Do not use conditional expressions. The order is not the same as the ternary operator in C++ and JavaScript, so it should be avoided: # Yes if foo : a = \"ok\" else : a = \"nope\" # No: a = \"ok\" if foo else \"nope\" Use if ... in ... when you can: # Yes if value in ( \"option1\" , \"option2\" ): ... # No if value == \"option1\" or value == \"option2\" ... Doc strings and comments in production code \u00b6 First off, bad comments are worse that no comments. Also note that you should use comments to explain why , never what . If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead. In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful. Note: this does not apply for tests (see below). Collections \u00b6 Use .extend() instead of += to concatenate lists: # Yes list_1 . extend ( list_2 ) # No list_1 += list_2 * Only use list() and dict() to convert a value to a list or dict. Prefer literals when possible # Yes my_list = [] my_dict = {} # Also yes: my_list = list ( yield_stuff ()) # No my_list = list () my_dict = dict () Also use explicit call to list() in order to make a copy: # Yes my_copy = list ( my_list ) # Also yes: my_copy = copy . copy ( my_list ) # No my_copy = my_list [:] Use list comprehensions instead of loops and \"functional\" methods: # Yes my_list = [ foo ( x ) for x in other_list ] # No my_list = list () for x in other_list : x . append ( foo ( x )) # Also no my_list = map ( foo , other_list ) # Yes even_nums = [ x for x in nums if is_even ( x )] # No even_nums = filter ( is_even , nums ) Use iterable syntax instead of building an explicit list: # Yes max ( len ( x ) for x in my_iterable ) # No max ([ len ( x ) for x in my_iterable ]) Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names: for result in results : # do something with result Functions \u00b6 Prefer using keyword-only parameters when possible: # Yes # If the parameter needs a default value: def foo ( bar , * , spam = True ): ... # If it does not: def foo ( bar , * , spam ): ... # No def foo ( bar , spam = True ): ... If you use the last form, Python will let you use foo(42, False) , and set spam to False. This can cause problems if someone ever changes the foo function and adds a new optional argument before spam : def foo ( bar , eggs = False , spam = True ): ... After such a change, the line foo(42, False) which used to call foo with spam=False now calls foo with bar=False and spam=True , leading to all kinds of interesting bugs. Exception to this rule: when the keyword is obvious and will not change: def get ( value , default = None ): ... Imports \u00b6 For any foo.py file, import foo must never fail, unless there is a necessary module that could not be found. Do not catch ImportError unless it is necessary, for instance to deal with optional dependencies. import required_module HAS_NICE_FEATURE = True try : import nice_lib except ImportError : HAS_NICE_FEATURE = False #... if HAS_NICE_FEATURE : #.... Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a if __name__ == main() block . Prefer using fully-qualified imports and names: # Yes import foo.bar my_bar = foo . bar . Bar () # No from foo import bar my_bar = bar . Bar () Note We allow a few exceptions like from pathlib import Path or importing classes directory in tests. Use your best judgment. Classes \u00b6 When you want to make sure a class follows an interface, use abc.ABCMeta instead of raising NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called. # Yes class AbstractFoo ( metaclass = abc . ABCMeta ): @abc . abstractmethod def foo ( self ): pass # No class AbstractFoo : def foo ( self ): raise NotImplementedError () Make sure to use properties when relevant, instead of get_ methods. # Yes class Person : def __init__ ( self , first_name , last_name ): self . first_name = first_name self . last_name = last_name @property def full_name ( self ): return f \" { self . first_name } { self . last_name } \" # No: class Foo : def __init__ ( self , first_name , last_name ): self . first_name = first_name self . last_name = last_name self . full_name = f \" { self . first_name } { self . last_name } \" For instance, here: full_name is read-only The attribute is automatically updated if first_name changes after the object is initialized. Note that get_ methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...) File paths \u00b6 If you are manipulating filenames, use the path.py library and suffix the variable by _path . Avoid using os.path or shutil methods when path.py is better. # Yes work_path = Path ( \"foo/work\" ) work_path . mkdir_p () foo_path = work_path / \"foo.txt\" foo_path . write_text ( \"this is bar\" ) # No work_path = os . path . join ( foo , \"work\" ) os . path . mkdir ( work_path , exist_ok = True ) foo_path = os . path . join ( work_path , \"foo.txt\" ) with open ( foo_path , \"w\" ) as fileobj : fileobj . write ( \"this is foo\" ) Error handling \u00b6 All exceptions raised from within tsrc should derive from tsrc.Error . When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them. Output messages to the user \u00b6 Do not use print , use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away print statements you add for debugging. Also, using \"high-level\" methods such as ui.info_1() or ui.warning() will make it easier to have a consistent user interface. Tests \u00b6 Docstrings \u00b6 If you think the test implementation is complex, add a human-readable description of the test scenario in the doc string. For instance: def test_sync_with_errors ( ... ): \"\"\"\" Scenario: * Create a manifest with two repos (foo and bar) * Initialize a workspace from this manifest * Push a new file to the foo repo * Create a merge conflict in the foo repo * Run `tsrc sync` * Check that the command fails and produces the proper error message \"\"\" Assertions with lists \u00b6 Use tuple unpacking to write shorter assertions: # Yes actual_list = function_that_returns_list () ( first , second ) = actual_list assert first == something assert second == something_else # NO actual_list = function_that_returns_list () assert len ( actual_list ) == 2 first = actual_list [ 0 ] second = actual_list [ 1 ] assert first == something assert second == something_else Assertion order \u00b6 When writing assertions, use the form assert <actual> == <expected> : # Yes def test_foo (): assert foo ( 42 ) == True def test_big_stuff (): actual_result = ... expected_result = ... assert actual_result == expected_result # No def test_foo (): assert True == foo ( 42 ) def test_big_stuff (): actual_result = ... expected_result = ... assert expected_result == actual_result Rationale: The assert(expected, actual) convention comes from JUnit but we are not writing Java code, and besides, the assert(actual, expected) convention also exists in other tools. pytest does not really care, but we prefer being consistent in all tests. It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\" .","title":"Code manifesto"},{"location":"code-manifesto/#code_manifesto","text":"","title":"Code Manifesto"},{"location":"code-manifesto/#basics","text":"We use black to enforce a coding style matching PEP8 . In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set core.autocrlf to true in your git config file.)","title":"Basics"},{"location":"code-manifesto/#pet_peeves","text":"Prefer double quotes for string literals: # Yes def bar (): \"\"\" bar stuff \"\"\" a = \"foo\" # No def bar (): ''' bar stuff ''' a = 'foo' # Exception my_str = 'It contains some \"quotes\" inside' Use the fact that empty data structures are falsy: # Yes if not errors : ... # No if len ( errors ) == 0 : ... Avoid using double negatives: # Yes def make_coffee ( sugar = False ): if sugar : print ( \"with sugar\" ) # No def make_coffee ( without_sugar = True ): if not without_sugar : print ( \"with sugar\" ) Prefer using \"f-strings\" if possible, + may also work in some contexts. # Yes message = f \"Welcome { name } !\" # No message = \"Welcome, {} !\" . format ( name ) message = \"Welcome, %s !\" % name message = \"Welcome, \" + name + \"!\" # Okayish with_ext = name + \".txt\" Use textwrap.dedent() to build nice-looking multi-lines strings: # Yes def foo (): long_message = textwrap . dedent ( \"\"\" \\ first line second line third line\"\"\" ) # No def foo (): long_message = \"\"\" \\ first line second line third line \"\"\" Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory) # Yes ok , mess = run_command () for test_result in test_results : outcome , message = res # No foo , bar = False , \"\" class Foo : self . bar , self . baz = None , True Do not use conditional expressions. The order is not the same as the ternary operator in C++ and JavaScript, so it should be avoided: # Yes if foo : a = \"ok\" else : a = \"nope\" # No: a = \"ok\" if foo else \"nope\" Use if ... in ... when you can: # Yes if value in ( \"option1\" , \"option2\" ): ... # No if value == \"option1\" or value == \"option2\" ...","title":"Pet peeves"},{"location":"code-manifesto/#doc_strings_and_comments_in_production_code","text":"First off, bad comments are worse that no comments. Also note that you should use comments to explain why , never what . If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead. In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful. Note: this does not apply for tests (see below).","title":"Doc strings and comments in production code"},{"location":"code-manifesto/#collections","text":"Use .extend() instead of += to concatenate lists: # Yes list_1 . extend ( list_2 ) # No list_1 += list_2 * Only use list() and dict() to convert a value to a list or dict. Prefer literals when possible # Yes my_list = [] my_dict = {} # Also yes: my_list = list ( yield_stuff ()) # No my_list = list () my_dict = dict () Also use explicit call to list() in order to make a copy: # Yes my_copy = list ( my_list ) # Also yes: my_copy = copy . copy ( my_list ) # No my_copy = my_list [:] Use list comprehensions instead of loops and \"functional\" methods: # Yes my_list = [ foo ( x ) for x in other_list ] # No my_list = list () for x in other_list : x . append ( foo ( x )) # Also no my_list = map ( foo , other_list ) # Yes even_nums = [ x for x in nums if is_even ( x )] # No even_nums = filter ( is_even , nums ) Use iterable syntax instead of building an explicit list: # Yes max ( len ( x ) for x in my_iterable ) # No max ([ len ( x ) for x in my_iterable ]) Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names: for result in results : # do something with result","title":"Collections"},{"location":"code-manifesto/#functions","text":"Prefer using keyword-only parameters when possible: # Yes # If the parameter needs a default value: def foo ( bar , * , spam = True ): ... # If it does not: def foo ( bar , * , spam ): ... # No def foo ( bar , spam = True ): ... If you use the last form, Python will let you use foo(42, False) , and set spam to False. This can cause problems if someone ever changes the foo function and adds a new optional argument before spam : def foo ( bar , eggs = False , spam = True ): ... After such a change, the line foo(42, False) which used to call foo with spam=False now calls foo with bar=False and spam=True , leading to all kinds of interesting bugs. Exception to this rule: when the keyword is obvious and will not change: def get ( value , default = None ): ...","title":"Functions"},{"location":"code-manifesto/#imports","text":"For any foo.py file, import foo must never fail, unless there is a necessary module that could not be found. Do not catch ImportError unless it is necessary, for instance to deal with optional dependencies. import required_module HAS_NICE_FEATURE = True try : import nice_lib except ImportError : HAS_NICE_FEATURE = False #... if HAS_NICE_FEATURE : #.... Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a if __name__ == main() block . Prefer using fully-qualified imports and names: # Yes import foo.bar my_bar = foo . bar . Bar () # No from foo import bar my_bar = bar . Bar () Note We allow a few exceptions like from pathlib import Path or importing classes directory in tests. Use your best judgment.","title":"Imports"},{"location":"code-manifesto/#classes","text":"When you want to make sure a class follows an interface, use abc.ABCMeta instead of raising NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called. # Yes class AbstractFoo ( metaclass = abc . ABCMeta ): @abc . abstractmethod def foo ( self ): pass # No class AbstractFoo : def foo ( self ): raise NotImplementedError () Make sure to use properties when relevant, instead of get_ methods. # Yes class Person : def __init__ ( self , first_name , last_name ): self . first_name = first_name self . last_name = last_name @property def full_name ( self ): return f \" { self . first_name } { self . last_name } \" # No: class Foo : def __init__ ( self , first_name , last_name ): self . first_name = first_name self . last_name = last_name self . full_name = f \" { self . first_name } { self . last_name } \" For instance, here: full_name is read-only The attribute is automatically updated if first_name changes after the object is initialized. Note that get_ methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...)","title":"Classes"},{"location":"code-manifesto/#file_paths","text":"If you are manipulating filenames, use the path.py library and suffix the variable by _path . Avoid using os.path or shutil methods when path.py is better. # Yes work_path = Path ( \"foo/work\" ) work_path . mkdir_p () foo_path = work_path / \"foo.txt\" foo_path . write_text ( \"this is bar\" ) # No work_path = os . path . join ( foo , \"work\" ) os . path . mkdir ( work_path , exist_ok = True ) foo_path = os . path . join ( work_path , \"foo.txt\" ) with open ( foo_path , \"w\" ) as fileobj : fileobj . write ( \"this is foo\" )","title":"File paths"},{"location":"code-manifesto/#error_handling","text":"All exceptions raised from within tsrc should derive from tsrc.Error . When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them.","title":"Error handling"},{"location":"code-manifesto/#output_messages_to_the_user","text":"Do not use print , use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away print statements you add for debugging. Also, using \"high-level\" methods such as ui.info_1() or ui.warning() will make it easier to have a consistent user interface.","title":"Output messages to the user"},{"location":"code-manifesto/#tests","text":"","title":"Tests"},{"location":"code-manifesto/#docstrings","text":"If you think the test implementation is complex, add a human-readable description of the test scenario in the doc string. For instance: def test_sync_with_errors ( ... ): \"\"\"\" Scenario: * Create a manifest with two repos (foo and bar) * Initialize a workspace from this manifest * Push a new file to the foo repo * Create a merge conflict in the foo repo * Run `tsrc sync` * Check that the command fails and produces the proper error message \"\"\"","title":"Docstrings"},{"location":"code-manifesto/#assertions_with_lists","text":"Use tuple unpacking to write shorter assertions: # Yes actual_list = function_that_returns_list () ( first , second ) = actual_list assert first == something assert second == something_else # NO actual_list = function_that_returns_list () assert len ( actual_list ) == 2 first = actual_list [ 0 ] second = actual_list [ 1 ] assert first == something assert second == something_else","title":"Assertions with lists"},{"location":"code-manifesto/#assertion_order","text":"When writing assertions, use the form assert <actual> == <expected> : # Yes def test_foo (): assert foo ( 42 ) == True def test_big_stuff (): actual_result = ... expected_result = ... assert actual_result == expected_result # No def test_foo (): assert True == foo ( 42 ) def test_big_stuff (): actual_result = ... expected_result = ... assert expected_result == actual_result Rationale: The assert(expected, actual) convention comes from JUnit but we are not writing Java code, and besides, the assert(actual, expected) convention also exists in other tools. pytest does not really care, but we prefer being consistent in all tests. It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\" .","title":"Assertion order"},{"location":"faq/","text":"FAQ \u00b6 What does the name mean? \u00b6 The t stands for tool and src for sources . If you speak French, you can also remember the name as \"tes sources\". Why not repo? \u00b6 We used repo for a while, but found that tsrc had both a better command line API and a nicer output. On a less subjective level: Good support for Windows (no need for Cygwin or anything like that) Also, tsrc tries hard to never do any destructive operation or unexpected actions. For instance, tsrc never puts you in a \"detached HEAD\" state, nor does automatic rebase. It also never touches dirty repositories. This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals. Also (and this matters a lot if you think about contribution): Uses PEP8 coding style, enforced with black Comprehensive test suite Fully type-checked with mypy Note that there are a few features present in repo that are missing from tsrc (but may be implemented in the future). Feel free to open a feature request if needed! Why not git-subrepo, mu-repo, or gr? \u00b6 All this projects are fine but did not match our needs: git-subrepo squashes commits, and we prefer having normal clones everywhere. mu-repo is nice and contains an interesting dependency management feature, but currently we do not need this complexity. In any case, now that the whole team is using tsrc all the time, it's likely we'll keep using tsrc in the future. Why not git submodule? \u00b6 It's all about workflow. With git-submodule , you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit. It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want. With tsrc , all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories. For instance, if you have foo and bar , you are going to make sure the 'master' branch of foo is always compatible to the 'master' branch of bar . Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 . Note that since tsrc 0.2 you can also freeze the commits of some of the repositories. Last but not least, if you really need to use fixed references, you may do so by adding a sha1 or tag line to the manifest. See the relevant guide for more details. Why not using pygit2 or similar instead of running git commands? \u00b6 First off, we do use pygit2 , but only for tests. Second, the pygit2 package depends on a 3rd party C library ( libgit2 ) - and that can cause problems in certain cases. If we can, we prefer using pure-Python libraries for the production code. Finally, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging (see below). Why do you hide which git commands are run? \u00b6 It's mainly a matter of not cluttering the output. We take care of keeping the output of tsrc both concise, readable and informative. That being said: In case a git command fails, we'll display the full command that was run. If you still need to see all the git commands that are run, we provide a --verbose flag, like so: tsrc --verbose sync Why YAML? \u00b6 It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support. Also, being Python fans, we don't mind that white space is part of the syntax. Why do I have to create a separate git repo with just one file in it? \u00b6 See #235 for why you can't have multiple manifest files in the same repository. Also, note that you can put other files in the repo - for instance, add a CI script that verifies the yaml syntax and checks that all the repos in the manifest can be cloned.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what_does_the_name_mean","text":"The t stands for tool and src for sources . If you speak French, you can also remember the name as \"tes sources\".","title":"What does the name mean?"},{"location":"faq/#why_not_repo","text":"We used repo for a while, but found that tsrc had both a better command line API and a nicer output. On a less subjective level: Good support for Windows (no need for Cygwin or anything like that) Also, tsrc tries hard to never do any destructive operation or unexpected actions. For instance, tsrc never puts you in a \"detached HEAD\" state, nor does automatic rebase. It also never touches dirty repositories. This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals. Also (and this matters a lot if you think about contribution): Uses PEP8 coding style, enforced with black Comprehensive test suite Fully type-checked with mypy Note that there are a few features present in repo that are missing from tsrc (but may be implemented in the future). Feel free to open a feature request if needed!","title":"Why not repo?"},{"location":"faq/#why_not_git-subrepo_mu-repo_or_gr","text":"All this projects are fine but did not match our needs: git-subrepo squashes commits, and we prefer having normal clones everywhere. mu-repo is nice and contains an interesting dependency management feature, but currently we do not need this complexity. In any case, now that the whole team is using tsrc all the time, it's likely we'll keep using tsrc in the future.","title":"Why not git-subrepo, mu-repo, or gr?"},{"location":"faq/#why_not_git_submodule","text":"It's all about workflow. With git-submodule , you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit. It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want. With tsrc , all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories. For instance, if you have foo and bar , you are going to make sure the 'master' branch of foo is always compatible to the 'master' branch of bar . Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 . Note that since tsrc 0.2 you can also freeze the commits of some of the repositories. Last but not least, if you really need to use fixed references, you may do so by adding a sha1 or tag line to the manifest. See the relevant guide for more details.","title":"Why not git submodule?"},{"location":"faq/#why_not_using_pygit2_or_similar_instead_of_running_git_commands","text":"First off, we do use pygit2 , but only for tests. Second, the pygit2 package depends on a 3rd party C library ( libgit2 ) - and that can cause problems in certain cases. If we can, we prefer using pure-Python libraries for the production code. Finally, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging (see below).","title":"Why not using pygit2 or similar instead of running git commands?"},{"location":"faq/#why_do_you_hide_which_git_commands_are_run","text":"It's mainly a matter of not cluttering the output. We take care of keeping the output of tsrc both concise, readable and informative. That being said: In case a git command fails, we'll display the full command that was run. If you still need to see all the git commands that are run, we provide a --verbose flag, like so: tsrc --verbose sync","title":"Why do you hide which git commands are run?"},{"location":"faq/#why_yaml","text":"It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support. Also, being Python fans, we don't mind that white space is part of the syntax.","title":"Why YAML?"},{"location":"faq/#why_do_i_have_to_create_a_separate_git_repo_with_just_one_file_in_it","text":"See #235 for why you can't have multiple manifest files in the same repository. Also, note that you can put other files in the repo - for instance, add a CI script that verifies the yaml syntax and checks that all the repos in the manifest can be cloned.","title":"Why do I have to create a separate git repo with just one file in it?"},{"location":"getting-started/","text":"Getting started \u00b6 Installing tsrc \u00b6 The recommended way to install tsrc is to use pipx Make sure to have Python 3.7 or later installed. Install pipx Run pipx install tsrc You can also install tsrc with pip if you know what you are doing :) Checking tsrc installation \u00b6 Run: $ tsrc --version Creating a repository for the manifest \u00b6 Let's say you are working for the ACME company and you have many git repositories. You need a tool to track them, so that if a new repository is created, all developers can get a clone on their development machine quickly, without having to look up its URL or even know it exists. Also, you need to make sure the repos are cloned in a certain way, so that you can for instance refer a repo from an other one by using a relative path. This is where tsrc comes in. The first step is to create a dedicated repository for the manifest. I know it may sound wasteful (\"I have already 100 repositories to manage, and you want me to create yet an other one?\"), but, trust me, it's worth it. So, if your company uses a GitLab instance at gitlab.acme.com and you want to crate a manifest for your team, you may start by creating a new repository at https://gitlab.acme.com/your-team/manifest . Inside this repository, create a file named manifest.yml looking like this: repos : - dest : foo url : git@gitlab.acme.com/your-team/foo - dest : bar url : git@gitlab.acme.com/your-team/bar Note that this approach works with any king of Git Hosting system, not just a custom GitLab instance. Just replace gitlab.acme.com/your-team with the correct suffix (like github.com/your-name/ if you want to track some repositories from your GitHub account). Creating a new workspace \u00b6 Create a new, empty directory and then run tsrc init from it, using the URL of the manifest created in the above step: $ mkdir work $ cd work $ tsrc init git@gitlab.acme.com/your-team/manifest.git You should see something like this: :: Configuring workspace in /path/to/work Cloning into 'manifest'... ... => Cloning missing repos * (1/2) Cloning foo Cloning into 'foo'... ... * (2/2) Cloning bar Cloning into 'bar'... ... => Cloned repos: * foo cloned from gt@gitlab.acme.com/your-team/foo' (on master) * bar cloned from gt@gitlab.acme.com/your-team/bar' (on master) => Configuring remotes => Workspace initialized => Configuration written in /path/to/work/.tsrc/config.yml You will notice that: The foo ad bar repositories have been cloned into their respective destination A workspace configuration file has been created in /path/to/work/.tsrc/config.yml . This file can be edited by hand to customize tsrc behavior. Follow the relevant guide , or read the workspace configuration file reference for more details. Updating a new workspace \u00b6 Now let's assume that Alice created a new commit in foo , and Bob a new commit it bar , and that they both pushed them to the master branch of the respective repositories. Now that you have a workspace configured with tsrc , you can use tsrc sync to retrieve all the changes in one go: $ cd work $ tsrc sync This time, you should see the following output: :: Using workspace in /path/to/work => Updating manifest ... => Cloning missing repos => Configuring remotes => Synchronizing repos * (1/2) Synchronizing foo * Fetching origin ... f20af74..aca6c35 master -> origin/master * Updating branch: master Updating f20af74..aca6c35 Fast-forward new.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 new.txt * (2/2) Synchronizing bar * Fetching origin ... f20af74..02cfef6 master -> origin/master * Updating branch: master Updating f20af74..02cfef6 Fast-forward spam.py | 1 + 1 file changed, 1 insertion(+) create mode 100644 spam.py :: Workspace synchronized Note: tsrc sync does not call git pull on every repository. The precise algorithm is described in the reference documentation Adding a new repo to the manifest \u00b6 Let's say your team now needs a third repository (for instance, at gitlab.acme.com/your-team/baz ). Start by making a commit in the manifest repository that adds the new repository: --- a/manifest.yml +++ b/manifest.yml @@ -1,2 +1,3 @@ repos: - dest: foo url: git@gitlab.acme.com/your-team/foo - dest: bar url: git@gitlab.acme.com/your-team/baz + - dest: baz + url: git@gitlab.acme.com/your-team/baz Then push this commit to the master branch of the manifest. This time when you run tsrc sync : the manifest repository will get updated the baz repo will be cloned in /path/to/work/baz $ tsrc sync :: Using workspace in /path/to/work => Updating manifest remote: Enumerating objects: 5, done. ... Unpacking objects: 100% (3/3), 354 bytes | 354.00 KiB/s, done. From gitlab.acme.com/your-team/manifest 63f12d4..bbcd4d9 master -> origin/master Reset branch 'master' ... HEAD is now at bbcd4d9 add baz => Cloning missing repos * (1/1) Cloning baz Cloning into 'baz'... ... Receiving objects: 100% (3/3), done. => Cloned repos: * baz cloned from git@gitlab.acme.com/bas (on master) => Configuring remotes => Synchronizing repos * (1/3) Synchronizing foo * Fetching origin * Updating branch: master Already up to date. * (2/3) Synchronizing bar * Fetching origin * Updating branch: master Already up to date. * (3/3) Synchronizing baz * Fetching origin * Updating branch: master Already up to date. :: Workspace synchronized Going further \u00b6 In this tutorial, we made a lot of assumptions: Every repository is using the master as the main development branch Each repository as only one git remote (the one from gitlab.acme.com in our example) You're using a manifest just for your team, not the whole company ... tsrc can handle all of this use cases, and more. See the other guides for more details.","title":"Getting Started"},{"location":"getting-started/#getting_started","text":"","title":"Getting started"},{"location":"getting-started/#installing_tsrc","text":"The recommended way to install tsrc is to use pipx Make sure to have Python 3.7 or later installed. Install pipx Run pipx install tsrc You can also install tsrc with pip if you know what you are doing :)","title":"Installing tsrc"},{"location":"getting-started/#checking_tsrc_installation","text":"Run: $ tsrc --version","title":"Checking tsrc installation"},{"location":"getting-started/#creating_a_repository_for_the_manifest","text":"Let's say you are working for the ACME company and you have many git repositories. You need a tool to track them, so that if a new repository is created, all developers can get a clone on their development machine quickly, without having to look up its URL or even know it exists. Also, you need to make sure the repos are cloned in a certain way, so that you can for instance refer a repo from an other one by using a relative path. This is where tsrc comes in. The first step is to create a dedicated repository for the manifest. I know it may sound wasteful (\"I have already 100 repositories to manage, and you want me to create yet an other one?\"), but, trust me, it's worth it. So, if your company uses a GitLab instance at gitlab.acme.com and you want to crate a manifest for your team, you may start by creating a new repository at https://gitlab.acme.com/your-team/manifest . Inside this repository, create a file named manifest.yml looking like this: repos : - dest : foo url : git@gitlab.acme.com/your-team/foo - dest : bar url : git@gitlab.acme.com/your-team/bar Note that this approach works with any king of Git Hosting system, not just a custom GitLab instance. Just replace gitlab.acme.com/your-team with the correct suffix (like github.com/your-name/ if you want to track some repositories from your GitHub account).","title":"Creating a repository for the manifest"},{"location":"getting-started/#creating_a_new_workspace","text":"Create a new, empty directory and then run tsrc init from it, using the URL of the manifest created in the above step: $ mkdir work $ cd work $ tsrc init git@gitlab.acme.com/your-team/manifest.git You should see something like this: :: Configuring workspace in /path/to/work Cloning into 'manifest'... ... => Cloning missing repos * (1/2) Cloning foo Cloning into 'foo'... ... * (2/2) Cloning bar Cloning into 'bar'... ... => Cloned repos: * foo cloned from gt@gitlab.acme.com/your-team/foo' (on master) * bar cloned from gt@gitlab.acme.com/your-team/bar' (on master) => Configuring remotes => Workspace initialized => Configuration written in /path/to/work/.tsrc/config.yml You will notice that: The foo ad bar repositories have been cloned into their respective destination A workspace configuration file has been created in /path/to/work/.tsrc/config.yml . This file can be edited by hand to customize tsrc behavior. Follow the relevant guide , or read the workspace configuration file reference for more details.","title":"Creating a new workspace"},{"location":"getting-started/#updating_a_new_workspace","text":"Now let's assume that Alice created a new commit in foo , and Bob a new commit it bar , and that they both pushed them to the master branch of the respective repositories. Now that you have a workspace configured with tsrc , you can use tsrc sync to retrieve all the changes in one go: $ cd work $ tsrc sync This time, you should see the following output: :: Using workspace in /path/to/work => Updating manifest ... => Cloning missing repos => Configuring remotes => Synchronizing repos * (1/2) Synchronizing foo * Fetching origin ... f20af74..aca6c35 master -> origin/master * Updating branch: master Updating f20af74..aca6c35 Fast-forward new.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 new.txt * (2/2) Synchronizing bar * Fetching origin ... f20af74..02cfef6 master -> origin/master * Updating branch: master Updating f20af74..02cfef6 Fast-forward spam.py | 1 + 1 file changed, 1 insertion(+) create mode 100644 spam.py :: Workspace synchronized Note: tsrc sync does not call git pull on every repository. The precise algorithm is described in the reference documentation","title":"Updating a new workspace"},{"location":"getting-started/#adding_a_new_repo_to_the_manifest","text":"Let's say your team now needs a third repository (for instance, at gitlab.acme.com/your-team/baz ). Start by making a commit in the manifest repository that adds the new repository: --- a/manifest.yml +++ b/manifest.yml @@ -1,2 +1,3 @@ repos: - dest: foo url: git@gitlab.acme.com/your-team/foo - dest: bar url: git@gitlab.acme.com/your-team/baz + - dest: baz + url: git@gitlab.acme.com/your-team/baz Then push this commit to the master branch of the manifest. This time when you run tsrc sync : the manifest repository will get updated the baz repo will be cloned in /path/to/work/baz $ tsrc sync :: Using workspace in /path/to/work => Updating manifest remote: Enumerating objects: 5, done. ... Unpacking objects: 100% (3/3), 354 bytes | 354.00 KiB/s, done. From gitlab.acme.com/your-team/manifest 63f12d4..bbcd4d9 master -> origin/master Reset branch 'master' ... HEAD is now at bbcd4d9 add baz => Cloning missing repos * (1/1) Cloning baz Cloning into 'baz'... ... Receiving objects: 100% (3/3), done. => Cloned repos: * baz cloned from git@gitlab.acme.com/bas (on master) => Configuring remotes => Synchronizing repos * (1/3) Synchronizing foo * Fetching origin * Updating branch: master Already up to date. * (2/3) Synchronizing bar * Fetching origin * Updating branch: master Already up to date. * (3/3) Synchronizing baz * Fetching origin * Updating branch: master Already up to date. :: Workspace synchronized","title":"Adding a new repo to the manifest"},{"location":"getting-started/#going_further","text":"In this tutorial, we made a lot of assumptions: Every repository is using the master as the main development branch Each repository as only one git remote (the one from gitlab.acme.com in our example) You're using a manifest just for your team, not the whole company ... tsrc can handle all of this use cases, and more. See the other guides for more details.","title":"Going further"},{"location":"contrib/dev/","text":"Suggesting changes \u00b6 All the development happens on GitHub . You are free to open a pull request for anything you want to change on tsrc . In particular, pull requests that implement a prototype for a new feature are welcome, having \"real code\" to look at can provide useful insight, even if the code is not merged after all. That being said, if you want your pull request to be merged, we'll ask that: The code follows the indications from the code manifesto All existing linters pass All existing tests run The new feature comes with appropriate tests The Git History is easy to review See the GitHub actions workflows to see what exactly what commands are run and the Python versions we support. Also, if relevant, you will need to: update the changelog (in docs/changelog.md ) update the documentation if required Finally, feel free to add your name in the THANKS file ;) Checking your changes \u00b6 Install latest poetry version. Install development and documentation dependencies: $ poetry install Run linters and tests: $ poetry run invoke lint $ poetry run pytest -n auto Adding documentation \u00b6 Follow the steps from the above section to setup your python environment Launch the development server locally: $ poetry run mkdocs serve Edit the markdown files from the docs/ folder and review the changes in your browser Finally, submit your changes by opening a pull request on GitHub","title":"Suggesting changes"},{"location":"contrib/dev/#suggesting_changes","text":"All the development happens on GitHub . You are free to open a pull request for anything you want to change on tsrc . In particular, pull requests that implement a prototype for a new feature are welcome, having \"real code\" to look at can provide useful insight, even if the code is not merged after all. That being said, if you want your pull request to be merged, we'll ask that: The code follows the indications from the code manifesto All existing linters pass All existing tests run The new feature comes with appropriate tests The Git History is easy to review See the GitHub actions workflows to see what exactly what commands are run and the Python versions we support. Also, if relevant, you will need to: update the changelog (in docs/changelog.md ) update the documentation if required Finally, feel free to add your name in the THANKS file ;)","title":"Suggesting changes"},{"location":"contrib/dev/#checking_your_changes","text":"Install latest poetry version. Install development and documentation dependencies: $ poetry install Run linters and tests: $ poetry run invoke lint $ poetry run pytest -n auto","title":"Checking your changes"},{"location":"contrib/dev/#adding_documentation","text":"Follow the steps from the above section to setup your python environment Launch the development server locally: $ poetry run mkdocs serve Edit the markdown files from the docs/ folder and review the changes in your browser Finally, submit your changes by opening a pull request on GitHub","title":"Adding documentation"},{"location":"contrib/issues/","text":"Using the issue tracker \u00b6 Reporting bugs and requesting new features is done one the tsrc issue tracker on GitHub . Reporting bugs \u00b6 If you are reporting a bug, please provide the following information: tsrc version Details about your environment (operating system, Python version) The exact command you run The full output Doing so will ensure we can investigate your bug right away. Suggesting new features \u00b6 If you think tsrc is lacking a feature, please provide the following information: What exactly is your use case? Do you need a new command-line option or even a new command? Do you need changes in the configuration files? Note that changing tsrc behavior can get tricky. First off, we want to avoid data loss following a tsrc command above Second, we want to keep tsrc behavior as least surprising as possible, so that it can be used without having to read (too much of) documentation. To that end, and keeping in mind tsrc needs to accommodate a large variety of use cases, we want to keep the code: easy to read and, easy to maintain, and very well tested. The best way to achieve all of this is to keep it simple . This means we'll be very cautious before implementing a new feature, so don't hesitate to open an issue for discussion before jumping into the development of a new feature.","title":"Using the issue tracker"},{"location":"contrib/issues/#using_the_issue_tracker","text":"Reporting bugs and requesting new features is done one the tsrc issue tracker on GitHub .","title":"Using the issue tracker"},{"location":"contrib/issues/#reporting_bugs","text":"If you are reporting a bug, please provide the following information: tsrc version Details about your environment (operating system, Python version) The exact command you run The full output Doing so will ensure we can investigate your bug right away.","title":"Reporting bugs"},{"location":"contrib/issues/#suggesting_new_features","text":"If you think tsrc is lacking a feature, please provide the following information: What exactly is your use case? Do you need a new command-line option or even a new command? Do you need changes in the configuration files? Note that changing tsrc behavior can get tricky. First off, we want to avoid data loss following a tsrc command above Second, we want to keep tsrc behavior as least surprising as possible, so that it can be used without having to read (too much of) documentation. To that end, and keeping in mind tsrc needs to accommodate a large variety of use cases, we want to keep the code: easy to read and, easy to maintain, and very well tested. The best way to achieve all of this is to keep it simple . This means we'll be very cautious before implementing a new feature, so don't hesitate to open an issue for discussion before jumping into the development of a new feature.","title":"Suggesting new features"},{"location":"guide/ci/","text":"Using tsrc with Continuous Integration (CI) \u00b6 GitHub Actions \u00b6 Let suppose you have a private GitHub organization holding several private repositories and tsrc to synchronize them using the SSH protocol. Let suppose you want to use GitHub Actions to download the code source of your organization, compile it and run some non regression tests. What to write to achieve this with tsrc? Step 1: Your tsrc manifest \u00b6 Your tsrc manifest.yml looks something like this: repos: - url: git@github.com:project1/foo dest: foo The git@ means SSH protocol. Step 2: Create your GitHub workflows file \u00b6 In your private GitHub repository holding the GitHub workflows files, create the folder .github/workflows and your yaml file with the desired name and the following content. For more information about GitHub actions syntax see this video : name: tsrc with private github repos on: workflow_dispatch: branches: - main jobs: export_linux: runs-on: ubuntu-latest steps: - name: Installing tsrc tool run: | sudo apt-get update sudo apt-get install -y python3 python -m pip install tsrc - name: Cloning private github repos run: | git config --global url.\"https://${{ secrets.ACCESS_TOKEN }}@github.com/\".insteadOf git@github.com: export WORKSPACE=$GITHUB_WORKSPACE/your_project mkdir -p $WORKSPACE cd $WORKSPACE tsrc init git@github.com:yourorganisation/manifest.git tsrc sync This script will run on the latest Ubuntu Docker and triggers steps: - The first step named Installing tsrc tool allows to install python3 and then tsrc. - The second step named Cloning private github repos creates a folder named your_project for your workspace and call the initialization and synchronization of your repositories. The important command is: git config --global url.\"https://${{ secrets.ACCESS_TOKEN }}@github.com/\".insteadOf git@github.com: which allows to replace the SSH syntax by the HTTPs syntax on your GitHub repository names. Step 3: Create the GitHub secret \u00b6 For GitHub organization one member of the team has the responsibility to hold a Personal access tokens for the organization. Go https://github.com/settings/tokens and click on the button Generate new token then click on repo checkbox then click on the button Generate token . Now, this token shall be saved into an action secret named ACCESS_TOKEN inside the GitHub repository holding the GitHub workflows files. Step 4: Enjoy \u00b6 In the menu Actions of your repository you can trig the workflow. In this example we used workflow_dispatch to perform manual triggers. So click on the button to start the process. Once this step done with success, you can update your workflow yaml to complete your CI work: compilation of your project, run non regression tests, etc.","title":"Using tsrc with continuous integration"},{"location":"guide/ci/#using_tsrc_with_continuous_integration_ci","text":"","title":"Using tsrc with Continuous Integration (CI)"},{"location":"guide/ci/#github_actions","text":"Let suppose you have a private GitHub organization holding several private repositories and tsrc to synchronize them using the SSH protocol. Let suppose you want to use GitHub Actions to download the code source of your organization, compile it and run some non regression tests. What to write to achieve this with tsrc?","title":"GitHub Actions"},{"location":"guide/ci/#step_1_your_tsrc_manifest","text":"Your tsrc manifest.yml looks something like this: repos: - url: git@github.com:project1/foo dest: foo The git@ means SSH protocol.","title":"Step 1: Your tsrc manifest"},{"location":"guide/ci/#step_2_create_your_github_workflows_file","text":"In your private GitHub repository holding the GitHub workflows files, create the folder .github/workflows and your yaml file with the desired name and the following content. For more information about GitHub actions syntax see this video : name: tsrc with private github repos on: workflow_dispatch: branches: - main jobs: export_linux: runs-on: ubuntu-latest steps: - name: Installing tsrc tool run: | sudo apt-get update sudo apt-get install -y python3 python -m pip install tsrc - name: Cloning private github repos run: | git config --global url.\"https://${{ secrets.ACCESS_TOKEN }}@github.com/\".insteadOf git@github.com: export WORKSPACE=$GITHUB_WORKSPACE/your_project mkdir -p $WORKSPACE cd $WORKSPACE tsrc init git@github.com:yourorganisation/manifest.git tsrc sync This script will run on the latest Ubuntu Docker and triggers steps: - The first step named Installing tsrc tool allows to install python3 and then tsrc. - The second step named Cloning private github repos creates a folder named your_project for your workspace and call the initialization and synchronization of your repositories. The important command is: git config --global url.\"https://${{ secrets.ACCESS_TOKEN }}@github.com/\".insteadOf git@github.com: which allows to replace the SSH syntax by the HTTPs syntax on your GitHub repository names.","title":"Step 2: Create your GitHub workflows file"},{"location":"guide/ci/#step_3_create_the_github_secret","text":"For GitHub organization one member of the team has the responsibility to hold a Personal access tokens for the organization. Go https://github.com/settings/tokens and click on the button Generate new token then click on repo checkbox then click on the button Generate token . Now, this token shall be saved into an action secret named ACCESS_TOKEN inside the GitHub repository holding the GitHub workflows files.","title":"Step 3: Create the GitHub secret"},{"location":"guide/ci/#step_4_enjoy","text":"In the menu Actions of your repository you can trig the workflow. In this example we used workflow_dispatch to perform manual triggers. So click on the button to start the process. Once this step done with success, you can update your workflow yaml to complete your CI work: compilation of your project, run non regression tests, etc.","title":"Step 4: Enjoy"},{"location":"guide/fixed-refs/","text":"Using fixed git references \u00b6 By default, tsrc sync synchronize projects using branches names . Usually, one would use the same branch name for several git repositories, like this: repos : - dest : foo url : git@gitlab.acme.com/your-team/foo branch : main - dest : bar url : git@gitlab.acme.com/your-team/bar branch : main The assumption here is that foo and bar evolve \"at the same time\", so when the main branch of foo is updated, the main branch of bar much change too. Sometimes though, this will not be the case. For instance, the main branch of the bar repo needs a specific, fixed version of foo in order to work. Using a tag \u00b6 One way to solve this is to push a v1.0 tag in the foo repository, and change the manifest too look like this: repos: - dest: foo url: git@gitlab.acme.com/your-team/foo - branch: main + tag: v1.0 Using a sha1 \u00b6 An other way is to put the SHA1 of the relevant git commit in the foo repository in the manifest: repos: - dest: foo url: git@gitlab.acme.com/your-team/foo branch: main + sha1: ad2b68539c78e749a372414165acdf2a1bb68203 Cloning repos using fixed refs \u00b6 If the repo is configured with a tag, tsrc will call git clone --branch <tag> (which is valid) Otherwise, tsrc will call git clone , followed by git reset --hard <sha1> This is because you cannot tell git to use an arbitrary git reference as start branch when cloning (tags are fine, but sha1s are not). This also explain why you need both branch and sha1 in the configuration. Synchronizing repos using fixed refs \u00b6 Here's what tsrc sync will do when trying to synchronize a repo configured with a fixed ref: Run git fetch --tags --prune Check if the repository is clean If so, run git reset --hard <tag or sha1>","title":"Using fixed git references"},{"location":"guide/fixed-refs/#using_fixed_git_references","text":"By default, tsrc sync synchronize projects using branches names . Usually, one would use the same branch name for several git repositories, like this: repos : - dest : foo url : git@gitlab.acme.com/your-team/foo branch : main - dest : bar url : git@gitlab.acme.com/your-team/bar branch : main The assumption here is that foo and bar evolve \"at the same time\", so when the main branch of foo is updated, the main branch of bar much change too. Sometimes though, this will not be the case. For instance, the main branch of the bar repo needs a specific, fixed version of foo in order to work.","title":"Using fixed git references"},{"location":"guide/fixed-refs/#using_a_tag","text":"One way to solve this is to push a v1.0 tag in the foo repository, and change the manifest too look like this: repos: - dest: foo url: git@gitlab.acme.com/your-team/foo - branch: main + tag: v1.0","title":"Using a tag"},{"location":"guide/fixed-refs/#using_a_sha1","text":"An other way is to put the SHA1 of the relevant git commit in the foo repository in the manifest: repos: - dest: foo url: git@gitlab.acme.com/your-team/foo branch: main + sha1: ad2b68539c78e749a372414165acdf2a1bb68203","title":"Using a sha1"},{"location":"guide/fixed-refs/#cloning_repos_using_fixed_refs","text":"If the repo is configured with a tag, tsrc will call git clone --branch <tag> (which is valid) Otherwise, tsrc will call git clone , followed by git reset --hard <sha1> This is because you cannot tell git to use an arbitrary git reference as start branch when cloning (tags are fine, but sha1s are not). This also explain why you need both branch and sha1 in the configuration.","title":"Cloning repos using fixed refs"},{"location":"guide/fixed-refs/#synchronizing_repos_using_fixed_refs","text":"Here's what tsrc sync will do when trying to synchronize a repo configured with a fixed ref: Run git fetch --tags --prune Check if the repository is clean If so, run git reset --hard <tag or sha1>","title":"Synchronizing repos using fixed refs"},{"location":"guide/foreach/","text":"Running a command for each repo in the workspace \u00b6 tsrc comes with a foreach command that allows you to run the same command for each repo in the workspace. This can be used for several things. For instance, if you are building an artifact from a group of repositories, you may want to put a tag on each repo that was used to produce it: $ tsrc foreach git tag v1.2 :: Using workspace in /path/to/work :: Running `git tag v1.1` on 2 repos /path/to/work/foo $ git tag v1.2 /path/to/work/bar $ git tag v1.2 /path/to/work/baz $ git tag v1.2 OK \u2713 Caveats \u00b6 If the command you want to run contains arguments starting with - : you need to call foreach like this: $ tsrc foreach -- some-command --with-option By default, the command is passed \"as is\", without starting a shell. If you want to use a shell, use the -c option: $ tsrc foreach -c 'echo $PWD' Note that we need single quotes here to prevent the shell from expanding the PWD environment variable when tsrc is run. Using repo and manifest data \u00b6 The current tsrc implementation may not contain all the features your organization needs. The good news is that you can extend tsrc 's feature set by using tsrc foreach . Let's take an example, where you have a manifest containing foo and bar and both repos are configured to use a master branch. Here's what happens if you run tsrc sync with bar on the correct branch ( master ), and foo on an incorrect branch ( devel ): $ tsrc sync :: Using workspace in /path/to/work => Updating manifest ... => Cloning missing repos => Configuring remotes => Synchronizing repos * (1/2) Synchronizing foo * Fetching origin * Updating branch: devel Updating 702f428..2e4fb45 Fast-forward ... * (2/2) Synchronizing bar * Fetching origin * Updating branch: master Already up to date. Error: Failed to synchronize the following repos: * foo : Current branch: 'devel' does not match expected branch: 'master' If this happens with multiple repos, you may want a command to checkout the correct branch automatically. Here's one way to do it: $ tsrc foreach -c 'git checkout $TSRC_PROJECT_MANIFEST_BRANCH' Here we take advantage of the fact that tsrc sets the TSRC_PROJECT_MANIFEST_BRANCH environment variable correctly for each repository before running the command. Here's the whole list: Variable Description TSRC_WORKSPACE_PATH Full path of the workspace root TSRC_MANIFEST_BRANCH Branch of the manifest TSRC_MANIFEST_URL URL of the manifest TSRC_PROJECT_CLONE_URL URL used to clone the repo TSRC_PROJECT_DEST Relative path of the repo in the workspace TSRC_PROJECT_MANIFEST_BRANCH Branch configured in the manifest for this repo TSRC_PROJECT_REMOTE_<NAME> URL of the remote named 'NAME' TSRC_PROJECT_STATUS_DIRTY Set to true if the project is dirty, otherwise unset TSRC_PROJECT_STATUS_AHEAD Number of commits ahead of the remote ref TSRC_PROJECT_STATUS_BEHIND Number of commits behind the remote ref TSRC_PROJECT_STATUS_BRANCH Current branch of the repo TSRC_PROJECT_STATUS_SHA1 SHA1 of the current branch TSRC_PROJECT_STATUS_STAGED Number of files that are staged but not committed TSRC_PROJECT_STATUS_NOT_STAGED Number of files that are changed but not staged TSRC_PROJECT_STATUS_UNTRACKED Number of files that are untracked You can implement more complex behavior using the environment variables above, for instance: #!/bin/bash # in switch-and-pull if [[ \" ${ TSRC_PROJECT_STATUS_DIRTY } \" = \"true\" ]] ; then echo Error: project is dirty exit 1 fi git switch $TSRC_PROJECT_MANIFEST_BRANCH git pull $ tsrc foreach switch-and-pull :: Running `switch-and-pull` on 2 repos * (1/2) foo /path/to/foo $ switch-and-pull Switched to branch 'master' Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use \"git pull\" to update your local branch) Updating 9e7a8e4..5f9bbd4 Fast-forward * (2/2) bar /path/to/bar $ switch-and-pull Error: project is dirty Error: Command failed for 1 repo(s) * bar Of course, feel free to use your favorite programming language here :)","title":"Running a command for each repo in the workspace"},{"location":"guide/foreach/#running_a_command_for_each_repo_in_the_workspace","text":"tsrc comes with a foreach command that allows you to run the same command for each repo in the workspace. This can be used for several things. For instance, if you are building an artifact from a group of repositories, you may want to put a tag on each repo that was used to produce it: $ tsrc foreach git tag v1.2 :: Using workspace in /path/to/work :: Running `git tag v1.1` on 2 repos /path/to/work/foo $ git tag v1.2 /path/to/work/bar $ git tag v1.2 /path/to/work/baz $ git tag v1.2 OK \u2713","title":"Running a command for each repo in the workspace"},{"location":"guide/foreach/#caveats","text":"If the command you want to run contains arguments starting with - : you need to call foreach like this: $ tsrc foreach -- some-command --with-option By default, the command is passed \"as is\", without starting a shell. If you want to use a shell, use the -c option: $ tsrc foreach -c 'echo $PWD' Note that we need single quotes here to prevent the shell from expanding the PWD environment variable when tsrc is run.","title":"Caveats"},{"location":"guide/foreach/#using_repo_and_manifest_data","text":"The current tsrc implementation may not contain all the features your organization needs. The good news is that you can extend tsrc 's feature set by using tsrc foreach . Let's take an example, where you have a manifest containing foo and bar and both repos are configured to use a master branch. Here's what happens if you run tsrc sync with bar on the correct branch ( master ), and foo on an incorrect branch ( devel ): $ tsrc sync :: Using workspace in /path/to/work => Updating manifest ... => Cloning missing repos => Configuring remotes => Synchronizing repos * (1/2) Synchronizing foo * Fetching origin * Updating branch: devel Updating 702f428..2e4fb45 Fast-forward ... * (2/2) Synchronizing bar * Fetching origin * Updating branch: master Already up to date. Error: Failed to synchronize the following repos: * foo : Current branch: 'devel' does not match expected branch: 'master' If this happens with multiple repos, you may want a command to checkout the correct branch automatically. Here's one way to do it: $ tsrc foreach -c 'git checkout $TSRC_PROJECT_MANIFEST_BRANCH' Here we take advantage of the fact that tsrc sets the TSRC_PROJECT_MANIFEST_BRANCH environment variable correctly for each repository before running the command. Here's the whole list: Variable Description TSRC_WORKSPACE_PATH Full path of the workspace root TSRC_MANIFEST_BRANCH Branch of the manifest TSRC_MANIFEST_URL URL of the manifest TSRC_PROJECT_CLONE_URL URL used to clone the repo TSRC_PROJECT_DEST Relative path of the repo in the workspace TSRC_PROJECT_MANIFEST_BRANCH Branch configured in the manifest for this repo TSRC_PROJECT_REMOTE_<NAME> URL of the remote named 'NAME' TSRC_PROJECT_STATUS_DIRTY Set to true if the project is dirty, otherwise unset TSRC_PROJECT_STATUS_AHEAD Number of commits ahead of the remote ref TSRC_PROJECT_STATUS_BEHIND Number of commits behind the remote ref TSRC_PROJECT_STATUS_BRANCH Current branch of the repo TSRC_PROJECT_STATUS_SHA1 SHA1 of the current branch TSRC_PROJECT_STATUS_STAGED Number of files that are staged but not committed TSRC_PROJECT_STATUS_NOT_STAGED Number of files that are changed but not staged TSRC_PROJECT_STATUS_UNTRACKED Number of files that are untracked You can implement more complex behavior using the environment variables above, for instance: #!/bin/bash # in switch-and-pull if [[ \" ${ TSRC_PROJECT_STATUS_DIRTY } \" = \"true\" ]] ; then echo Error: project is dirty exit 1 fi git switch $TSRC_PROJECT_MANIFEST_BRANCH git pull $ tsrc foreach switch-and-pull :: Running `switch-and-pull` on 2 repos * (1/2) foo /path/to/foo $ switch-and-pull Switched to branch 'master' Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use \"git pull\" to update your local branch) Updating 9e7a8e4..5f9bbd4 Fast-forward * (2/2) bar /path/to/bar $ switch-and-pull Error: project is dirty Error: Command failed for 1 repo(s) * bar Of course, feel free to use your favorite programming language here :)","title":"Using repo and manifest data"},{"location":"guide/fs/","text":"Performing file system operations \u00b6 Introduction \u00b6 When using tsrc , it is assumed that repositories are put in non-overlapping file system hierarchies, like this: workspace/ project_1/ CMakeLists.txt foo.cpp bar.cpp project_2/ CMakeLists.txt spam.cpp eggs.cpp Not like that, where project_2 is inside a sub-directory of project_1 : workspace/ project_1/ CMakeLists.txt foo.cpp bar.cpp project_2/ CMakeLists.txt spam.cpp eggs.cpp Note if you really need project_2 to be a sub-directory of project_1 , consider using git submodules instead. This is usually fine, except when project_1 and project_2 share some common configuration. For instance, you may want to use clang-format for both project_1 and project_2 . Copying a file \u00b6 One solution is to put the .clang-format configuration file in a repo named common and then tell tsrc to copy it at the root of the workspace: repos : - dest : project_1 url : git@acme.com:team/project_1 - dest : project_2 url : git@acme.com:team/project_2 - dest : common url : git@acme.com:team/commont copy : - file : clang-format dest : .clang-format $ tsrc sync = > Cloning missing repos * ( 1 /1 ) Cloning common Cloning into 'common' ... ... = > Performing filesystem operations * ( 1 /1 ) Copy /path/to/work/common/clang-format -> /path/to/work/.clang-format Notes: copy only works with files, not directories. The source path for a copy link is relative to associated repos destination, whereas the destination path of the copy is relative to the workspace root. Creating a symlink \u00b6 The above method works fine if the file does not change too often - if not, you may want to create a symbolic link instead: repos : - dest : project_1 url : git@acme.com:team/project_1 - dest : project_2 url : git@acme.com:team/project_2 - dest : common url : git@acme.com:team/commont symlink : - source : .clang-format target : common/clang-format $ tsrc sync = > Cloning missing repos ... = > Performing filesystem operations * ( 1 /1 ) Lint /path/to/work/.clang-format -> common/.clang-format Notes: The source path for a symbolic link is relative to the top-level <workspace> , whereas each target path is then relative to the associated source. (This path relationship is essentially identical to how ln -s works on the command line in Unix-like environments.) Multiple symlinks can be specified; each must specify a source and target. Symlink creation is supported on all operating systems, but creation of NTFS symlinks on Windows requires that the current user have appropriate security policy permission (SeCreateSymbolicLinkPrivilege). By default, only administrators have that privilege set, although newer versions of Windows 10 support a Developer Mode that permits unprivileged accounts to create symlinks. Note that Cygwin running on Windows defaults to creating links via Windows shortcuts, which do not require any special privileges. (Cygwin's symlink behavior can be user controlled with the winsymlinks setting in the CYGWIN environment variable.)","title":"Performing file system operations"},{"location":"guide/fs/#performing_file_system_operations","text":"","title":"Performing file system operations"},{"location":"guide/fs/#introduction","text":"When using tsrc , it is assumed that repositories are put in non-overlapping file system hierarchies, like this: workspace/ project_1/ CMakeLists.txt foo.cpp bar.cpp project_2/ CMakeLists.txt spam.cpp eggs.cpp Not like that, where project_2 is inside a sub-directory of project_1 : workspace/ project_1/ CMakeLists.txt foo.cpp bar.cpp project_2/ CMakeLists.txt spam.cpp eggs.cpp Note if you really need project_2 to be a sub-directory of project_1 , consider using git submodules instead. This is usually fine, except when project_1 and project_2 share some common configuration. For instance, you may want to use clang-format for both project_1 and project_2 .","title":"Introduction"},{"location":"guide/fs/#copying_a_file","text":"One solution is to put the .clang-format configuration file in a repo named common and then tell tsrc to copy it at the root of the workspace: repos : - dest : project_1 url : git@acme.com:team/project_1 - dest : project_2 url : git@acme.com:team/project_2 - dest : common url : git@acme.com:team/commont copy : - file : clang-format dest : .clang-format $ tsrc sync = > Cloning missing repos * ( 1 /1 ) Cloning common Cloning into 'common' ... ... = > Performing filesystem operations * ( 1 /1 ) Copy /path/to/work/common/clang-format -> /path/to/work/.clang-format Notes: copy only works with files, not directories. The source path for a copy link is relative to associated repos destination, whereas the destination path of the copy is relative to the workspace root.","title":"Copying a file"},{"location":"guide/fs/#creating_a_symlink","text":"The above method works fine if the file does not change too often - if not, you may want to create a symbolic link instead: repos : - dest : project_1 url : git@acme.com:team/project_1 - dest : project_2 url : git@acme.com:team/project_2 - dest : common url : git@acme.com:team/commont symlink : - source : .clang-format target : common/clang-format $ tsrc sync = > Cloning missing repos ... = > Performing filesystem operations * ( 1 /1 ) Lint /path/to/work/.clang-format -> common/.clang-format Notes: The source path for a symbolic link is relative to the top-level <workspace> , whereas each target path is then relative to the associated source. (This path relationship is essentially identical to how ln -s works on the command line in Unix-like environments.) Multiple symlinks can be specified; each must specify a source and target. Symlink creation is supported on all operating systems, but creation of NTFS symlinks on Windows requires that the current user have appropriate security policy permission (SeCreateSymbolicLinkPrivilege). By default, only administrators have that privilege set, although newer versions of Windows 10 support a Developer Mode that permits unprivileged accounts to create symlinks. Note that Cygwin running on Windows defaults to creating links via Windows shortcuts, which do not require any special privileges. (Cygwin's symlink behavior can be user controlled with the winsymlinks setting in the CYGWIN environment variable.)","title":"Creating a symlink"},{"location":"guide/groups/","text":"Using groups \u00b6 Sometimes it can be necessary to create groups of repositories, especially if the number of repositories grows and if you have people in different teams work on different repositories. Defining groups in the manifest \u00b6 The first step is to edit the manifest.yml file to describe the groups. Here's an example. repos : - { url : git@gitlab.local : acme/one , dest : one } - { url : git@gitlab.local : acme/two , dest : two } - { url : git@gitlab.local : acme/three , dest : three } groups : default : repos : [] g1 : repos : - one - two g2 : repos : - three Here we define a g1 group that contains repositories named one and two , and a g2 group that contains the repository named three . Using groups in tsrc init \u00b6 If you only need the repositories in the g1 group you can run: tsrc init git@gitlab.local:acme/manifest --group g1 Filtering repositories in groups with regular expressions \u00b6 You can utilize inclusive regular expression with the -r -flag and exclusive regular expression with the -i -flag. This allows you to filter repositories within a group or a set of groups for the given action. To include all repositories in the group g1 matching \"config\" and excluding \"template\", you can do the following: tsrc init git@gitlab.local:acme/manifest --group g1 -r config -i template Updating workspace configuration \u00b6 Alternatively, you can edit the .tsrc/config.yml file, like this: manifest_url : git@gitlab.local:acme/manifest.git manifest_branch : master repo_groups : - g1 # <- specify the list of groups to use You can use this technique to change the groups used in a given workspace - the above method using init only works to create new workspaces. The config file contains other configuration options, which are described in the workspace configuration documentation .","title":"Using groups"},{"location":"guide/groups/#using_groups","text":"Sometimes it can be necessary to create groups of repositories, especially if the number of repositories grows and if you have people in different teams work on different repositories.","title":"Using groups"},{"location":"guide/groups/#defining_groups_in_the_manifest","text":"The first step is to edit the manifest.yml file to describe the groups. Here's an example. repos : - { url : git@gitlab.local : acme/one , dest : one } - { url : git@gitlab.local : acme/two , dest : two } - { url : git@gitlab.local : acme/three , dest : three } groups : default : repos : [] g1 : repos : - one - two g2 : repos : - three Here we define a g1 group that contains repositories named one and two , and a g2 group that contains the repository named three .","title":"Defining groups in the manifest"},{"location":"guide/groups/#using_groups_in_tsrc_init","text":"If you only need the repositories in the g1 group you can run: tsrc init git@gitlab.local:acme/manifest --group g1","title":"Using groups in tsrc init"},{"location":"guide/groups/#filtering_repositories_in_groups_with_regular_expressions","text":"You can utilize inclusive regular expression with the -r -flag and exclusive regular expression with the -i -flag. This allows you to filter repositories within a group or a set of groups for the given action. To include all repositories in the group g1 matching \"config\" and excluding \"template\", you can do the following: tsrc init git@gitlab.local:acme/manifest --group g1 -r config -i template","title":"Filtering repositories in groups with regular expressions"},{"location":"guide/groups/#updating_workspace_configuration","text":"Alternatively, you can edit the .tsrc/config.yml file, like this: manifest_url : git@gitlab.local:acme/manifest.git manifest_branch : master repo_groups : - g1 # <- specify the list of groups to use You can use this technique to change the groups used in a given workspace - the above method using init only works to create new workspaces. The config file contains other configuration options, which are described in the workspace configuration documentation .","title":"Updating workspace configuration"},{"location":"guide/manifest/","text":"Editing the manifest safely \u00b6 Introduction: when things go wrong \u00b6 Let's assume you've successfully implemented tsrc for your organization - now need to make sure to not break anyone's workflow. Let's see what could go wrong if you make mistakes while editing the manifest, using a branch called broken for the sake of the example). First, let's see what happens if you break the YAML syntax: commit 1633c5a6 (HEAD -> broken, origin/broken) Break the manifest syntax diff --git a/manifest.yml b/manifest.yml index fe74142..068c35e 100644 --- a/manifest.yml +++ b/manifest.yml @@ -1,4 +1,4 @@ -repos: +repos - url: git@github.com:your-tools/bar.git dest: bar After this change is push, anyone using the broken branch of the manifest will be faced with this kind of error message: $ tsrc sync => Updating manifest Reset branch 'broken' Your branch is up to date with 'origin/broken'. Branch 'broken' set up to track remote branch 'broken' from 'origin'. HEAD is now at 1633c5a Break the manifest syntax Error: /path/to/work/.tsrc/manifest/manifest.yml: mapping values are not allowed here : - url: git@gitlab.acme.com:your-team/foo ^ (line: 2) Similarly, if you put an invalid URL in the manifest, like this: commit ccfb902 (HEAD -> broken, origin/broken) Use invalid URL for bar repo diff --git a/manifest.yml b/manifest.yml index fe74142..068c35e 100644 --- a/manifest.yml +++ b/manifest.yml @@ -1,4 +1,4 @@ repos: - - url: git@gitlab.acme.com:your-team/bar + - url: git@gitlab.acme.com:your-team/invalid dest: bar Users will get: $ tsrc sync :: Using workspace in /path/to/work => Updating manifest ... HEAD is now at ccfb902 Use invalid URL => Cloning missing repos => Configuring remotes * bar: Update remote origin to new url: (git@acme.com:your-team/invalid.git) ... => Synchronizing repos * (1/2) Synchronizing bar * Fetching origin ERROR: Repository not found. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. Error: fetch from 'origin' failed * (2/2) Synchronizing foo ... Error: Failed to synchronize the following repos: * bar : fetch from 'origin' failed This will probably not be a huge problem for you, dear reader, because you know about tsrc's manifest and its syntax. It will , however, be a problem for people who are just using tsrc without knowledge of how it is implemented, because those error messages will definitely confuse them. Using the apply-manifest command to avoid breaking developers workflow \u00b6 If you have a file on your machine containing the manifest changes, you can use tsrc apply-manifest to check those changes against your own workspace: $ cd /path/to/work $ tsrc apply-manifest /path/to/manifest-repo/manifest.yml # Check that the changes are OK # If so, commit and push manifest changes: $ cd path/to/manifest-repo $ git commit -a -m \"...\" $ git push # Now you know that everyone can safely run `tsrc sync` Additional notes \u00b6 It is not advised to edit the file in .tsrc/manifest/manifest.yml directly, because tsrc sync will silently undo any local changes made to this file. This is a known bug, see #279 for details. It is common to place the manifest repo itself in the manifest - so it's easy to edit or read: # In acme.com:your-team/manifest - manifest.yml repos : - url : git@acme.com:your-team/manifest dest : manifest - url : git@acme.com:your-team/foo dest : foo - url : git@acme.com:your-team/bar dest : bar In that case, you would use: $ tsrc apply-manifest <workspace>/manifest/manifest.yml to check changes before pushing them.","title":"Editing the manifest safely"},{"location":"guide/manifest/#editing_the_manifest_safely","text":"","title":"Editing the manifest safely"},{"location":"guide/manifest/#introduction_when_things_go_wrong","text":"Let's assume you've successfully implemented tsrc for your organization - now need to make sure to not break anyone's workflow. Let's see what could go wrong if you make mistakes while editing the manifest, using a branch called broken for the sake of the example). First, let's see what happens if you break the YAML syntax: commit 1633c5a6 (HEAD -> broken, origin/broken) Break the manifest syntax diff --git a/manifest.yml b/manifest.yml index fe74142..068c35e 100644 --- a/manifest.yml +++ b/manifest.yml @@ -1,4 +1,4 @@ -repos: +repos - url: git@github.com:your-tools/bar.git dest: bar After this change is push, anyone using the broken branch of the manifest will be faced with this kind of error message: $ tsrc sync => Updating manifest Reset branch 'broken' Your branch is up to date with 'origin/broken'. Branch 'broken' set up to track remote branch 'broken' from 'origin'. HEAD is now at 1633c5a Break the manifest syntax Error: /path/to/work/.tsrc/manifest/manifest.yml: mapping values are not allowed here : - url: git@gitlab.acme.com:your-team/foo ^ (line: 2) Similarly, if you put an invalid URL in the manifest, like this: commit ccfb902 (HEAD -> broken, origin/broken) Use invalid URL for bar repo diff --git a/manifest.yml b/manifest.yml index fe74142..068c35e 100644 --- a/manifest.yml +++ b/manifest.yml @@ -1,4 +1,4 @@ repos: - - url: git@gitlab.acme.com:your-team/bar + - url: git@gitlab.acme.com:your-team/invalid dest: bar Users will get: $ tsrc sync :: Using workspace in /path/to/work => Updating manifest ... HEAD is now at ccfb902 Use invalid URL => Cloning missing repos => Configuring remotes * bar: Update remote origin to new url: (git@acme.com:your-team/invalid.git) ... => Synchronizing repos * (1/2) Synchronizing bar * Fetching origin ERROR: Repository not found. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. Error: fetch from 'origin' failed * (2/2) Synchronizing foo ... Error: Failed to synchronize the following repos: * bar : fetch from 'origin' failed This will probably not be a huge problem for you, dear reader, because you know about tsrc's manifest and its syntax. It will , however, be a problem for people who are just using tsrc without knowledge of how it is implemented, because those error messages will definitely confuse them.","title":"Introduction: when things go wrong"},{"location":"guide/manifest/#using_the_apply-manifest_command_to_avoid_breaking_developers_workflow","text":"If you have a file on your machine containing the manifest changes, you can use tsrc apply-manifest to check those changes against your own workspace: $ cd /path/to/work $ tsrc apply-manifest /path/to/manifest-repo/manifest.yml # Check that the changes are OK # If so, commit and push manifest changes: $ cd path/to/manifest-repo $ git commit -a -m \"...\" $ git push # Now you know that everyone can safely run `tsrc sync`","title":"Using the apply-manifest command to avoid breaking developers workflow"},{"location":"guide/manifest/#additional_notes","text":"It is not advised to edit the file in .tsrc/manifest/manifest.yml directly, because tsrc sync will silently undo any local changes made to this file. This is a known bug, see #279 for details. It is common to place the manifest repo itself in the manifest - so it's easy to edit or read: # In acme.com:your-team/manifest - manifest.yml repos : - url : git@acme.com:your-team/manifest dest : manifest - url : git@acme.com:your-team/foo dest : foo - url : git@acme.com:your-team/bar dest : bar In that case, you would use: $ tsrc apply-manifest <workspace>/manifest/manifest.yml to check changes before pushing them.","title":"Additional notes"},{"location":"guide/remotes/","text":"Using several remotes \u00b6 When you specify a repository in the manifest with just an URL, tsrc assumes you want a remote named origin: repos : - dest : foo url : git@gitlab.acme.com/your-team/foo - dest : bar url : git@gitlab.acme.com/your-team/bar But sometimes you need several remotes. Let's see a few use cases. Mirroring open-source projects \u00b6 If you want some repos in your organization to be open source, you may need: a remote named 'origin' containing for the private repository on your GitLab instance a remote named 'github' for the public repository on GitHub In that case, you can use an alternative syntax: repos : # foo is open source and thus needs two remotes: - dest : foo - remotes : - name : origin url : git@gitlab.acme.com/your-team/foo - name : github url : git@github.com/your-team/foo # bar is closed source and thus only needs the # default, 'origin' remote: - dest : bar url : gitlab.acme.com/your-team/bar After this change, when running tsrc init or tsrc sync , both the origin and github remotes will be created in the foo repo if they don't exist, and both remotes will be fetched when using tsrc sync . Using a VPN \u00b6 Sometimes you will need two remotes, because depending the physical location of your developers, they need to use either: a 'normal' remote, when they are in the office a 'vpn' remote, when they are working at home In that case, you can create a manifest looking like this: repos : - dest : foo - remotes : - name : origin url : git@gitlab.local/your-team/foo - name : vpn url : git@myvpn.com/gitlab/your-team/foo - dest : bar - remotes : - name : origin url : git@gitlab.local/your-team/bar - name : vpn url : git@myvpn.com/gitlab/your-team/bar Developers can then use the -r, --singular-remote option to either use the origin or vpn when running tsrc init (to create a workspace), or tsrc sync (to synchronize it), depending on their physical location: # Init the workspace using the 'vpn' remote $ tsrc init -r vpn # Bring back the computer in the office # Synchronize using the 'origin' remote: $ tsrc sync -r origin Note When using this option, tsrc expects the remote to be present in the manifest for all repositories.","title":"Using several remotes"},{"location":"guide/remotes/#using_several_remotes","text":"When you specify a repository in the manifest with just an URL, tsrc assumes you want a remote named origin: repos : - dest : foo url : git@gitlab.acme.com/your-team/foo - dest : bar url : git@gitlab.acme.com/your-team/bar But sometimes you need several remotes. Let's see a few use cases.","title":"Using several remotes"},{"location":"guide/remotes/#mirroring_open-source_projects","text":"If you want some repos in your organization to be open source, you may need: a remote named 'origin' containing for the private repository on your GitLab instance a remote named 'github' for the public repository on GitHub In that case, you can use an alternative syntax: repos : # foo is open source and thus needs two remotes: - dest : foo - remotes : - name : origin url : git@gitlab.acme.com/your-team/foo - name : github url : git@github.com/your-team/foo # bar is closed source and thus only needs the # default, 'origin' remote: - dest : bar url : gitlab.acme.com/your-team/bar After this change, when running tsrc init or tsrc sync , both the origin and github remotes will be created in the foo repo if they don't exist, and both remotes will be fetched when using tsrc sync .","title":"Mirroring open-source projects"},{"location":"guide/remotes/#using_a_vpn","text":"Sometimes you will need two remotes, because depending the physical location of your developers, they need to use either: a 'normal' remote, when they are in the office a 'vpn' remote, when they are working at home In that case, you can create a manifest looking like this: repos : - dest : foo - remotes : - name : origin url : git@gitlab.local/your-team/foo - name : vpn url : git@myvpn.com/gitlab/your-team/foo - dest : bar - remotes : - name : origin url : git@gitlab.local/your-team/bar - name : vpn url : git@myvpn.com/gitlab/your-team/bar Developers can then use the -r, --singular-remote option to either use the origin or vpn when running tsrc init (to create a workspace), or tsrc sync (to synchronize it), depending on their physical location: # Init the workspace using the 'vpn' remote $ tsrc init -r vpn # Bring back the computer in the office # Synchronize using the 'origin' remote: $ tsrc sync -r origin Note When using this option, tsrc expects the remote to be present in the manifest for all repositories.","title":"Using a VPN"},{"location":"guide/workspace-config/","text":"Editing workspace configuration \u00b6 Creation \u00b6 The configuration file created by tsrc init contains the whole list of available settings, with their default value, and is located at </path/to/workspace/.tsrc/manifest.yml> . Note that if you use command-line options when using tsrc init , those will be written in the .tsrc/config.yml . For instance: tsrc init git@github.com:dmerejkowsky/dummy-manifest generates this file: manifest_url : git@github.com:dmerejkowsky/dummy-manifest manifest_branch : master repo_groups : [] shallow_clones : false clone_all_repos : false singular_remote : But tsrc init git@github.com:dmerejkowsky/dummy-manifest --branch main generates this instead: manifest_url : git@github.com:dmerejkowsky/dummy-manifest manifest_branch : main repo_groups : [] shallow_clones : false clone_all_repos : false singular_remote : Editing \u00b6 You can edit the workspace configuration as you please, for instance if you need to switch the manifest branch. If you do so, note that your changes will be taken into account next time you run tsrc sync .","title":"Editing workspace configuration"},{"location":"guide/workspace-config/#editing_workspace_configuration","text":"","title":"Editing workspace configuration"},{"location":"guide/workspace-config/#creation","text":"The configuration file created by tsrc init contains the whole list of available settings, with their default value, and is located at </path/to/workspace/.tsrc/manifest.yml> . Note that if you use command-line options when using tsrc init , those will be written in the .tsrc/config.yml . For instance: tsrc init git@github.com:dmerejkowsky/dummy-manifest generates this file: manifest_url : git@github.com:dmerejkowsky/dummy-manifest manifest_branch : master repo_groups : [] shallow_clones : false clone_all_repos : false singular_remote : But tsrc init git@github.com:dmerejkowsky/dummy-manifest --branch main generates this instead: manifest_url : git@github.com:dmerejkowsky/dummy-manifest manifest_branch : main repo_groups : [] shallow_clones : false clone_all_repos : false singular_remote :","title":"Creation"},{"location":"guide/workspace-config/#editing","text":"You can edit the workspace configuration as you please, for instance if you need to switch the manifest branch. If you do so, note that your changes will be taken into account next time you run tsrc sync .","title":"Editing"},{"location":"ref/cli/","text":"Command line usage \u00b6 Important note \u00b6 We use the argparse library to parse command line arguments, so the --help messages are always up-to-date, probably more so than this documentation :) General \u00b6 tsrc uses the same \"subcommand\" pattern as git does. Options common to all commands are placed right before the command name. Options after the command name only apply to this command. For instance: $ tsrc --verbose sync $ tsrc init MANIFEST_URL Goodies \u00b6 First, note that like git , tsrc will walk up the folders hierarchy looking for a .tsrc folder, which means you can run tsrc commands anywhere in your workspace, not just at the top. Second, almost all commands run the operation in parallel. For instance, tsrc sync by default will use as many jobs as the number of CPUs available on the current machine to synchronize the repos in your workspace. If this behavior is not desired, you can specify a greater (or lower) number of jobs using something like tsrc sync -j2 , or disable the parallelism completely with -j1 . You can also set the default number of jobs by using the TSRC_PARALLEL_JOBS environment variable. Global options \u00b6 --verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal) Usage \u00b6 tsrc init MANIFEST_URL [--group GROUP1, GROUP2] [--singular-remote SINGULAR_REMOTE] Initializes a new workspace. MANIFEST_URL should be a git URL containing a valid manifest.yml file. The -g,--groups option can be used to specify a list of groups to use when cloning repositories. The -r \"inclusive regular expression\" and -i \"exclusive regular expression\" options can be combined with the group option to filter for repositories within a group. -r takes precedence if both options are present. The -s,--shallow option can be used to make shallow clone of all repositories. If you want to add or remove a group in your workspace, you can edit the configuration file in <workspace>/.tsrc/config.yml The -r,--singular-remote option can be used to set a fixed remote to use when cloning and syncing the repositories. If this flag is set, the remote from the manifest with the given name will be used for all repos. It is an error if a repo does not have this remote specified. tsrc foreach -- command --opt1 arg1 Runs command --opt1 arg1 in every repository, and report failures at the end. Note the -- token to separate options for command from options for tsrc . tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell ( /bin/sh on Linux or macOS, cmd.exe on Windows). tsrc log --from FROM [--to TO] Display a summary of all changes since FROM (should be a tag), to TO (defaulting to master ). Note that if no changes are found, the repository will not be displayed at all. tsrc status Displays a summary of the status of your workspace: Shows dirty repositories Shows repositories not on the expected branch tsrc sync [--correct-branch/-c] Updates all the repositories and shows a summary at the end. If any of the repositories is not on the configured branch, but it is clean and the --correct-branch / -c flag is set, then the branch is changed to the configured one and then the repository is updated. Otherwise that repository will not be not updated. tsrc version Displays tsrc version number, along additional data if run from a git clone. tsrc apply-manifest PATH Apply changes from the manifest file located at PATH . Useful to check changes in the manifest before publishing them to the manifest repository.","title":"Command line usage"},{"location":"ref/cli/#command_line_usage","text":"","title":"Command line usage"},{"location":"ref/cli/#important_note","text":"We use the argparse library to parse command line arguments, so the --help messages are always up-to-date, probably more so than this documentation :)","title":"Important note"},{"location":"ref/cli/#general","text":"tsrc uses the same \"subcommand\" pattern as git does. Options common to all commands are placed right before the command name. Options after the command name only apply to this command. For instance: $ tsrc --verbose sync $ tsrc init MANIFEST_URL","title":"General"},{"location":"ref/cli/#goodies","text":"First, note that like git , tsrc will walk up the folders hierarchy looking for a .tsrc folder, which means you can run tsrc commands anywhere in your workspace, not just at the top. Second, almost all commands run the operation in parallel. For instance, tsrc sync by default will use as many jobs as the number of CPUs available on the current machine to synchronize the repos in your workspace. If this behavior is not desired, you can specify a greater (or lower) number of jobs using something like tsrc sync -j2 , or disable the parallelism completely with -j1 . You can also set the default number of jobs by using the TSRC_PARALLEL_JOBS environment variable.","title":"Goodies"},{"location":"ref/cli/#global_options","text":"--verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal)","title":"Global options"},{"location":"ref/cli/#usage","text":"tsrc init MANIFEST_URL [--group GROUP1, GROUP2] [--singular-remote SINGULAR_REMOTE] Initializes a new workspace. MANIFEST_URL should be a git URL containing a valid manifest.yml file. The -g,--groups option can be used to specify a list of groups to use when cloning repositories. The -r \"inclusive regular expression\" and -i \"exclusive regular expression\" options can be combined with the group option to filter for repositories within a group. -r takes precedence if both options are present. The -s,--shallow option can be used to make shallow clone of all repositories. If you want to add or remove a group in your workspace, you can edit the configuration file in <workspace>/.tsrc/config.yml The -r,--singular-remote option can be used to set a fixed remote to use when cloning and syncing the repositories. If this flag is set, the remote from the manifest with the given name will be used for all repos. It is an error if a repo does not have this remote specified. tsrc foreach -- command --opt1 arg1 Runs command --opt1 arg1 in every repository, and report failures at the end. Note the -- token to separate options for command from options for tsrc . tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell ( /bin/sh on Linux or macOS, cmd.exe on Windows). tsrc log --from FROM [--to TO] Display a summary of all changes since FROM (should be a tag), to TO (defaulting to master ). Note that if no changes are found, the repository will not be displayed at all. tsrc status Displays a summary of the status of your workspace: Shows dirty repositories Shows repositories not on the expected branch tsrc sync [--correct-branch/-c] Updates all the repositories and shows a summary at the end. If any of the repositories is not on the configured branch, but it is clean and the --correct-branch / -c flag is set, then the branch is changed to the configured one and then the repository is updated. Otherwise that repository will not be not updated. tsrc version Displays tsrc version number, along additional data if run from a git clone. tsrc apply-manifest PATH Apply changes from the manifest file located at PATH . Useful to check changes in the manifest before publishing them to the manifest repository.","title":"Usage"},{"location":"ref/manifest-config/","text":"Manifest configuration \u00b6 The manifest configuration must be stored in a file named manifest.yml , using YAML syntax. It is always parsed as a mapping . Here's an example: repos : - url : git@gitlab.local:proj1/foo dest : foo branch : next - remotes : - name : origin url : git@gitlab.local:proj1/bar - name : upstream url : git@github.com:user/bar dest : bar branch : master sha1 : ad2b68539c78e749a372414165acdf2a1bb68203 - url : git@gitlab.local:proj1/app dest : app tag : v0.1 copy : - file : top.cmake dest : CMakeLists.txt - file : .clangformat symlink : - source : app/some_file target : ../foo/some_file In this example: First, proj1/foo will be cloned into <workspace>/foo using the next branch. Then, proj1/bar will be cloned into <workspace>/bar using the master branch, and reset to ad2b68539c78e749a372414165acdf2a1bb68203 . Finally: proj1/app will be cloned into <workspace>/app using the v0.1 tag, top.cmake will be copied from proj1/app/top.cmake to <workspace>/CMakeLists.txt , .clang-format will be copied from proj1/app/ to <workspace>/ , and a symlink will be created from <workspace>/app/some_file to <workspace>/foo/some_file . Top fields \u00b6 repos (required): list of repositories to clone groups (optional): list of groups repos \u00b6 Each repository is also a mapping , containing: Either: url if you just need one remote named origin A list of remotes with a name and url . In that case, the first remote will be used for cloning the repository. dest (required): relative path of the repository in the workspace branch (optional): The branch to use when cloning the repository (defaults to master ) tag (optional): When running tsrc init : Project will be cloned at the provided tag. When running tsrc sync : If the project is clean, project will be reset to the given tag, else a warning message will be printed. sha1 (optional): When running tsrc init : Project will be cloned, and then reset to the given sha1. When running tsrc sync : If the project is clean, project will be reset to the given sha1, else a warning message will be printed. ignore_submodules (optional, default= false ): When running tsrc init : if ignore_submodules is true , do not recursively clone submodules. When running tsrc sync : if ignore_submodules is true , do not initialize or update submodules. to the given sha1, else a warning message will be printed. copy (optional): A list of mappings with file and dest keys. symlink (optional): A list of mappings with source and target keys. See the Using fixed references and the Performing file system operations guides for details about how and why you would use the tag , sha1 , copy or symlink fields. groups \u00b6 The groups section lists the groups by name. Each group should have a repos field containing a list of repositories (only repositories defined in the repos section are allowed). The groups can optionally include other groups, with a includes field which should be a list of existing group names. The group named default , if it exists, will be used to know which repositories to clone when using tsrc init and the --group command line argument is not used. Example: repos : - dest : a url : .. - dest : b url : .. - dest : bar url : .. - dest : baz url : .. groups : default : repos : [ a , b ] foo : repos : [ bar , baz ] includes : [ default ] $ tsrc init <manifest_url> # Clones a, b $ tsrc init <manifest_url> --group foo # Clones a, b, bar and baz Note that tsrc init records the names of the groups it was invoked with, so that tsrc sync re-uses them later on. This means that if you want to change the groups used, you must re-run tsrc init with the new group list. Note More information about how to use groups is available in the relevant guide .","title":"Manifest configuration"},{"location":"ref/manifest-config/#manifest_configuration","text":"The manifest configuration must be stored in a file named manifest.yml , using YAML syntax. It is always parsed as a mapping . Here's an example: repos : - url : git@gitlab.local:proj1/foo dest : foo branch : next - remotes : - name : origin url : git@gitlab.local:proj1/bar - name : upstream url : git@github.com:user/bar dest : bar branch : master sha1 : ad2b68539c78e749a372414165acdf2a1bb68203 - url : git@gitlab.local:proj1/app dest : app tag : v0.1 copy : - file : top.cmake dest : CMakeLists.txt - file : .clangformat symlink : - source : app/some_file target : ../foo/some_file In this example: First, proj1/foo will be cloned into <workspace>/foo using the next branch. Then, proj1/bar will be cloned into <workspace>/bar using the master branch, and reset to ad2b68539c78e749a372414165acdf2a1bb68203 . Finally: proj1/app will be cloned into <workspace>/app using the v0.1 tag, top.cmake will be copied from proj1/app/top.cmake to <workspace>/CMakeLists.txt , .clang-format will be copied from proj1/app/ to <workspace>/ , and a symlink will be created from <workspace>/app/some_file to <workspace>/foo/some_file .","title":"Manifest configuration"},{"location":"ref/manifest-config/#top_fields","text":"repos (required): list of repositories to clone groups (optional): list of groups","title":"Top fields"},{"location":"ref/manifest-config/#repos","text":"Each repository is also a mapping , containing: Either: url if you just need one remote named origin A list of remotes with a name and url . In that case, the first remote will be used for cloning the repository. dest (required): relative path of the repository in the workspace branch (optional): The branch to use when cloning the repository (defaults to master ) tag (optional): When running tsrc init : Project will be cloned at the provided tag. When running tsrc sync : If the project is clean, project will be reset to the given tag, else a warning message will be printed. sha1 (optional): When running tsrc init : Project will be cloned, and then reset to the given sha1. When running tsrc sync : If the project is clean, project will be reset to the given sha1, else a warning message will be printed. ignore_submodules (optional, default= false ): When running tsrc init : if ignore_submodules is true , do not recursively clone submodules. When running tsrc sync : if ignore_submodules is true , do not initialize or update submodules. to the given sha1, else a warning message will be printed. copy (optional): A list of mappings with file and dest keys. symlink (optional): A list of mappings with source and target keys. See the Using fixed references and the Performing file system operations guides for details about how and why you would use the tag , sha1 , copy or symlink fields.","title":"repos"},{"location":"ref/manifest-config/#groups","text":"The groups section lists the groups by name. Each group should have a repos field containing a list of repositories (only repositories defined in the repos section are allowed). The groups can optionally include other groups, with a includes field which should be a list of existing group names. The group named default , if it exists, will be used to know which repositories to clone when using tsrc init and the --group command line argument is not used. Example: repos : - dest : a url : .. - dest : b url : .. - dest : bar url : .. - dest : baz url : .. groups : default : repos : [ a , b ] foo : repos : [ bar , baz ] includes : [ default ] $ tsrc init <manifest_url> # Clones a, b $ tsrc init <manifest_url> --group foo # Clones a, b, bar and baz Note that tsrc init records the names of the groups it was invoked with, so that tsrc sync re-uses them later on. This means that if you want to change the groups used, you must re-run tsrc init with the new group list. Note More information about how to use groups is available in the relevant guide .","title":"groups"},{"location":"ref/sync/","text":"Sync algorithm \u00b6 You may have noticed that tsrc sync does not just calls git pull on every repository. Here's the algorithm that is used: Run git fetch --tags --prune Check if the repository is on a branch Check if the currently checked out branch matches the one configured in the manifest. If it does not but the --correct-branch flag is set and the repository is clean, the branch is changed to the configured one. Check if the repository is dirty Try and run a fast-forward merge Note that: git fetch is always called so that local refs are up-to-date tsrc will simply print an error and move on to the next repository if the fast-forward merge is not possible. That's because tsrc cannot guess what the correct action is, so it prefers doing nothing. It's up to the user to run something like git merge or git rebase . in case the repository is on an incorrect branch, the fast-forward merge will still be attempted, but an error message will be show in the end","title":"Sync algorithm"},{"location":"ref/sync/#sync_algorithm","text":"You may have noticed that tsrc sync does not just calls git pull on every repository. Here's the algorithm that is used: Run git fetch --tags --prune Check if the repository is on a branch Check if the currently checked out branch matches the one configured in the manifest. If it does not but the --correct-branch flag is set and the repository is clean, the branch is changed to the configured one. Check if the repository is dirty Try and run a fast-forward merge Note that: git fetch is always called so that local refs are up-to-date tsrc will simply print an error and move on to the next repository if the fast-forward merge is not possible. That's because tsrc cannot guess what the correct action is, so it prefers doing nothing. It's up to the user to run something like git merge or git rebase . in case the repository is on an incorrect branch, the fast-forward merge will still be attempted, but an error message will be show in the end","title":"Sync algorithm"},{"location":"ref/workspace-config/","text":"Workspace configuration \u00b6 The workspace configuration lies in <workspace>/.tsrc/config.yml . It is created by tsrc init then read by tsrc sync and other commands. It can be freely edited by hand. Here's an example: manifest_url : git@acme.corp:manifest.git manifest_branch : master shallow_clones : false repo_groups : - default clone_all_repos : false singular_remote : manifest_url : an git URL containing a manifest.yml file manifest_branch : the branch to use when updating the local manifest (e.g, the first step of tsrc sync ) shallow_clones : whether to use only shallow clones when cloning missing repositories repo_groups : the list of groups to use - every mentioned group must be present in the manifest.yml file (see above) clone_all_repos : whether to ignore groups entirely and clone every repository from the manifest instead singular_remote : if set to <remote-name> , behaves as if tsrc sync and tsrc init were called with --singular-remote <remote-name> option. See the Using remotes guide for details.","title":"Workspace configuration"},{"location":"ref/workspace-config/#workspace_configuration","text":"The workspace configuration lies in <workspace>/.tsrc/config.yml . It is created by tsrc init then read by tsrc sync and other commands. It can be freely edited by hand. Here's an example: manifest_url : git@acme.corp:manifest.git manifest_branch : master shallow_clones : false repo_groups : - default clone_all_repos : false singular_remote : manifest_url : an git URL containing a manifest.yml file manifest_branch : the branch to use when updating the local manifest (e.g, the first step of tsrc sync ) shallow_clones : whether to use only shallow clones when cloning missing repositories repo_groups : the list of groups to use - every mentioned group must be present in the manifest.yml file (see above) clone_all_repos : whether to ignore groups entirely and clone every repository from the manifest instead singular_remote : if set to <remote-name> , behaves as if tsrc sync and tsrc init were called with --singular-remote <remote-name> option. See the Using remotes guide for details.","title":"Workspace configuration"}]}