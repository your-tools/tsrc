{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tsrc_-_managing_groups_of_git_repositories","title":"tsrc - managing groups of git repositories","text":""},{"location":"#what_it_does","title":"What it does","text":"<p><code>tsrc</code> is a command-line tool that helps you manage groups of git repositories.</p> <p>It works by listing the repositories in a file called <code>manifest.yml</code> that looks like this:</p> <pre><code>repos:\n  - dest: foo\n    url: git@example.com:foo.git\n\n  - dest: bar\n    url: git@example.com:bar.git\n</code></pre> <p>You can then use:</p> <ul> <li> <p><code>tsrc init &lt;manifest url&gt;</code> to create a workspace containing   the <code>foo</code> and <code>bar</code> repository</p> </li> <li> <p><code>tsrc sync</code> to synchronize all repos in the workspace.</p> </li> <li> <p>... and many more commands. Run <code>tsrc help</code> to list them, or read the command line reference</p> </li> </ul>"},{"location":"#tutorial","title":"Tutorial","text":"<p>Interested in using <code>tsrc</code> in your own organization?</p> <p>Proceed to the getting started tutorial!</p>"},{"location":"#guides","title":"Guides","text":"<p>Once you've learn how to setup tsrc for your organization, feel free to read the following guides - tsrc supports a variety of use cases beyond just listing git repositories to be cloned or synchronized and are described here:</p> <ul> <li>Editing the manifest safely</li> <li>Editing workspace configuration</li> <li>Using groups</li> <li>Using several remotes</li> <li>Using fixed git references</li> <li>Performing file system operations</li> <li>Running a command for each repo in the workspace</li> <li>Using tsrc with continuous integration</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Command line interface</li> <li>Sync algorithm</li> <li>Manifest configuration</li> <li>Workspace configuration</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Using the issue tracker</li> <li>Suggesting changes</li> <li>Code Manifesto</li> </ul>"},{"location":"#useful_links","title":"Useful links","text":"<ul> <li>FAQ</li> <li>Changelog</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#271_2022-05-30","title":"2.7.1 (2022-05-30)","text":"<ul> <li>In addition to preserving the order repos are listed in the manifest,   <code>tsrc</code> now makes sure repos included via groups are processed before   the other repos. See #356 for details. Thanks to @raabf for the bug report   and code review!</li> </ul>"},{"location":"changelog/#270_2022-05-14","title":"2.7.0 (2022-05-14)","text":"<ul> <li>Show which git commands are run by default.</li> <li><code>tsrc init</code>: fix order of operations - clone the local manifest before   writing the workspace configuration. Fixes #344, where users could not run <code>init</code> a second   time if the previous call failed. Bug report by @cgestes.</li> <li><code>tsrc init</code>: do not assume the default branch of the manifest is <code>master</code>. Note that <code>master</code> is still hard-coded in a few places. See #347 for details.</li> <li>Breaking: When using <code>-j 1</code>, do not sort repositories by lexical order of destination, but preserve   the order in which they were specified in the manifest. Suggested by @raabf.</li> </ul>"},{"location":"changelog/#260_2022-03-27","title":"2.6.0 (2022-03-27)","text":"<ul> <li>Allow to use <code>python -m tsrc</code> in addition to just <code>tsrc</code></li> <li>Documentation updates</li> <li>Bump mypy</li> </ul>"},{"location":"changelog/#250_2022-12-21","title":"2.5.0 (2022-12-21)","text":""},{"location":"changelog/#highlights","title":"Highlights","text":"<ul> <li>Bump minimum supported version to Python 3.7.</li> <li>Introduce <code>ignore_submodules</code> repository option - Patch by Thomas Hiscock.</li> <li>When <code>-j</code> is not used, try getting the default <code>jobs</code> value from the   <code>TSRC_PARALLEL_JOBS</code> environment variable.  Patch by Marcin Jaworski.</li> </ul>"},{"location":"changelog/#other","title":"Other","text":"<ul> <li>Bump mkdocs from 1.2.2 to 1.2.3</li> <li>Bump pygit2</li> <li>Bump linters (flake8, mypy, black)</li> <li>Remove dependency on <code>attr</code></li> </ul>"},{"location":"changelog/#241_2021-11-05","title":"2.4.1 (2021-11-05)","text":"<ul> <li>Ad more guides in the documentation</li> <li>Display absolute paths when performing file system operations</li> <li><code>tsrc sync</code> now uses parallel jobs by default. Use <code>-j1</code> to force   sequential processing. Patch by @gdubicki</li> </ul>"},{"location":"changelog/#240_2021-08-22","title":"2.4.0 (2021-08-22)","text":""},{"location":"changelog/#highlights_1","title":"Highlights","text":"<ul> <li> <p>All of <code>tsrc</code> commands can now be run in parallel. Try for instance <code>tsrc sync -j auto</code>.</p> </li> <li> <p><code>tsrc foreach</code> now sets a bunch of environment variables. This allows   developers to add new behaviors to tsrc without having to change its source code. See   the relevant guide for more information.</p> </li> <li> <p>Augment documentation with more use cases and examples (still a work in progress)</p> </li> </ul>"},{"location":"changelog/#breaking_changes","title":"Breaking changes","text":"<ul> <li> <p>Remove <code>tsrc version</code> - Use <code>tsrc --version</code> instead.</p> </li> <li> <p>The 'parallel' feature caused the output of some commands like   <code>foreach</code> or <code>log</code> to change slightly. Hopefully   <code>tsrc</code> output is now more consistent.</p> </li> </ul>"},{"location":"changelog/#bug_fixes","title":"Bug fixes","text":"<ul> <li> <p>Fix crash when running <code>tsrc</code> without any arguments</p> </li> <li> <p>Fix crash when trying to clone repositories in some rare corner cases   (like the destination existing but not being a directory)</p> </li> </ul>"},{"location":"changelog/#internal_changes","title":"Internal changes","text":"<ul> <li>Make all <code>tsrc</code> imports consistent</li> <li>Fix error when calling <code>repr</code> on <code>tsrc</code> Errors.</li> </ul>"},{"location":"changelog/#231_2021-06-28","title":"2.3.1 (2021-06-28)","text":""},{"location":"changelog/#bug_fixes_and_small_improvements","title":"Bug fixes and small improvements","text":"<ul> <li>Fix #268: <code>tsrc apply-manifest</code> now performs file system operation</li> <li>Always display workspace path at the beginning of any action</li> <li>Skip \"performing file system operations\" message if there is no   work to be done</li> </ul>"},{"location":"changelog/#internal_changes_1","title":"Internal changes","text":"<ul> <li>Bump linters and formatters  (<code>black</code>, <code>mypy</code>, <code>isort</code> ...)</li> <li>Use <code>copier</code> to simplify maintenance of tools configuration</li> </ul>"},{"location":"changelog/#230_2021-05-31","title":"2.3.0 (2021-05-31)","text":""},{"location":"changelog/#repo_selection","title":"Repo selection","text":"<ul> <li>Added -r (regex) and -i (inverse regex) params for filtering repos. Patch by @xzr</li> </ul>"},{"location":"changelog/#add_support_for_submodules","title":"Add support for submodules","text":"<ul> <li><code>tsrc</code> calls <code>git clone</code> with <code>--recurse-submodules</code> when adding missing repositories</li> <li><code>tsrc</code> calls <code>git submodule update --init --recursive</code> when updating repositories</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Remove codecov usage</li> <li>Rename default branch to <code>main</code>.</li> </ul>"},{"location":"changelog/#221_2021-04-10","title":"2.2.1 (2021-04-10)","text":"<ul> <li> <p>Project has been moved from <code>TankerHQ</code> organization to <code>dmerejkowsky</code>. New urls are:</p> <ul> <li>github.com/dmerejkowsky/tsrc for the git repository</li> <li>dmerejkowsky.github.io/tsrc for the documentation</li> </ul> </li> <li> <p>Add CI jobs to check this project also works with Python 3.9</p> </li> <li>Drop <code>Path Pie</code> dependency</li> <li>Minor internal fixes</li> <li>Add more URLs in the metadata (and pypi.org project page)</li> </ul>"},{"location":"changelog/#220_2020-07-17","title":"2.2.0 (2020-07-17)","text":""},{"location":"changelog/#add_symlink_support","title":"Add symlink support","text":"<p><code>tsrc sync</code> and <code>tsrc init</code> can now create symlinks as specified in the manifest file:</p> <pre><code>repos:\n\n  - url: git@gitlab.local:proj1/app\n    dest: app\n    symlink:\n      - source: app/some_file\n        target: ../some_file\n</code></pre> <p>In this case, a symlink will be created from <code>&lt;workspace&gt;/app/some_file</code> to <code>&lt;workspace&gt;/some_file</code>. (both <code>source</code> and <code>target</code> keys are relative to the repository's destination).</p>"},{"location":"changelog/#changes_related_to_groups","title":"Changes related to groups","text":"<ul> <li>log, status, and sync all learned about the <code>--group</code> option and the <code>--all-cloned</code> options</li> <li>foreach: remove the <code>--groups-from-config</code> options since this is now the default behavior</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Rework FAQ</li> <li>Run black in <code>lint.sh</code></li> <li>Fix formatting of some messages</li> <li>Update code manifesto to suggest using docstrings in tests</li> </ul>"},{"location":"changelog/#210_2020-05-27","title":"2.1.0 (2020-05-27)","text":""},{"location":"changelog/#breaking_changes_1","title":"Breaking changes","text":""},{"location":"changelog/#change_in_manifest_syntax","title":"Change in manifest syntax","text":"<p>It was discovered that the manifest syntax was confusing for newcomers, so we decided to update it.</p> <p>In particular, the <code>src</code> key meant both a relative path in the workspace when used in the <code>repo</code> config, and a relative path in the a repository when using in the <code>repo.copy</code> config.</p> <p>Starting with this release, <code>repo.src</code> becomes <code>repo.dest</code> and <code>repo.copy.src</code> becomes <code>repo.copy.file</code>.</p> <pre><code># Before (tsrc &lt; 2.1.0)\nrepos:\n  url: \"https://acme.corp/foo\"\n  src: foo\n  copy:\n     src: some-file\n     dest: some-file\n</code></pre> <pre><code># After (tsrc &gt;= 2.1.0)\nrepos:\n  url: \"https://acme.corp/foo\"\n  dest : foo\n  copy:\n     file: some-file\n     dest: some-file\n</code></pre> <p>This should make it clearer what <code>tsrc</code> does because:</p> <ul> <li><code>dest</code> now always refers to a relative path in the workspace (both in <code>repo</code> and <code>copy</code>).</li> <li>By using <code>repo.copy.file</code> it's obvious that <code>tsrc</code> only supports copying   files, not directories.</li> </ul>"},{"location":"changelog/#supported_python_versions","title":"Supported Python versions","text":"<p>Drop support for Python 3.5</p>"},{"location":"changelog/#new_features","title":"New features","text":"<ul> <li><code>tsrc init</code> learned a <code>-r, --remote</code> option that pins the remote with the    given name as the only remote to be used for cloning and syncing.    <code>tsrc</code> expects this remote to be present in the manifest for all repositories.    This is useful if you use the same workspace in different physical locations,    and one of the remotes is behind a VPN for instance. Patch by @tronje.</li> </ul>"},{"location":"changelog/#bug_fixes_1","title":"Bug fixes","text":"<ul> <li>Fix #217: Preserves file attributes during the <code>copy</code> statements in <code>repos</code></li> </ul>"},{"location":"changelog/#other_1","title":"Other","text":"<ul> <li>The whole test suite now runs without errors on Windows - and Windows support is   now part of the GitHub actions checks.</li> <li>The tests now run faster and with more readable output (this was done by using <code>libgit2</code>   instead of running git commands in the tests helpers).</li> <li>Add a scheduled GitHub action to run <code>safety</code></li> <li>Remove usage of deprecated API of the <code>path</code> library.</li> <li>Run tests and linters for external pull requests too.</li> </ul>"},{"location":"changelog/#v200_-_2020-04-06","title":"v2.0.0 - (2020-04-06)","text":"<ul> <li> <p>Remove the <code>tsrc push</code> command and all review automation features. Please   use hub, lab,   or repo instead.   See #207 for the discussion leading   to this removal.</p> </li> <li> <p>Implement small improvements on <code>tsrc</code> output messages.</p> </li> <li>Add <code>tsrc apply-manifest</code>, to apply changes in a manifest file locally, without   having to make a commit and push to a server first.</li> </ul>"},{"location":"changelog/#v103_-_2020-02-05","title":"v1.0.3 - (2020-02-05)","text":"<ul> <li>Use poetry for dependency management and packaging.</li> </ul>"},{"location":"changelog/#v102_-_2020-01-29","title":"v1.0.2 - (2020-01-29)","text":"<ul> <li>Fix <code>python_requires</code> value in project metadata</li> </ul>"},{"location":"changelog/#v101_-_2020-01-21","title":"v1.0.1 - (2020-01-21)","text":"<ul> <li>Fix #196: Do not attempt file copies for non-cloned repositories when using <code>tsrc init</code> with a list of groups.</li> </ul>"},{"location":"changelog/#v100_-_2020-01-09","title":"v1.0.0 - (2020-01-09)","text":"<p>Starting the new year with a stable release, at last!</p>"},{"location":"changelog/#revamp_group_ux","title":"Revamp group UX","text":"<p>The changes below in the configuration file and command line syntax allow for better UX regarding groups. See the corresponding milestone for the full list.</p>"},{"location":"changelog/#new_configuration_file","title":"New configuration file","text":"<p>Previously, <code>tsrc</code> stored its permanent configuration in <code>.tsrc/manifest.yml</code> and the file was not supposed to be edited by hand. Instead, users could use <code>tsrc init</code> to modify it, for instance with the <code>--branch</code> argument.</p> <p>Starting with this release, the command <code>tsrc init</code> can only be run once per workspace, and you must edit the <code>.tsrc/config.yml</code> file instead.</p>"},{"location":"changelog/#changes_in_command_line_syntax","title":"Changes in command line syntax","text":"<ul> <li><code>tsrc init</code>: remove <code>--file</code> option.</li> <li><code>tsrc foreach</code>: instead of repeating the <code>--group</code> option, you can use <code>--groups</code> with a list of groups:</li> </ul> <pre><code># before\ntsrc init --group foo --group bar\n\n# after\ntsrc init --groups foo bar\n</code></pre> <ul> <li> <p><code>tsrc init</code> learned a <code>--clone-all-repos</code> option to clone all repositories from the manifest,   regardless of the groups. Fix #181</p> </li> <li> <p>Remove <code>--file</code> option from <code>tsrc init</code>.</p> </li> <li> <p><code>tsrc foreach</code> learned a <code>--groups-from-config</code> option to use the groups configured in the workspace. Fix #178, #179.</p> </li> <li> <p><code>tsrc push</code> learned a <code>-o, --origin</code> option to specify a remote name different from \"origin\". Fix #170</p> </li> </ul>"},{"location":"changelog/#other_fixes","title":"Other fixes","text":"<ul> <li>Try and check that GitLab installation support required features before using them -   typically, using <code>tsrc push --approvers</code> on GitLab Community Edition. (#165)</li> <li>reported by @irizzant.</li> <li>Switch to GitHub actions for running tests and linters. Also, publish documentation automatically   when something is pushed to the <code>master</code> branch.</li> <li><code>tsrc status</code> : add information when local branch does not match manifest   configuration. (#190). Feature suggested by @janjachnick</li> </ul>"},{"location":"changelog/#v092_-_2019-09-30","title":"v0.9.2 - (2019-09-30)","text":"<ul> <li>Additional bug fix for #165 - the fix in 0.9.1 was incomplete</li> <li>Improve error message when trying to use non-supported GitLab features (like using <code>tsrc push --reviewer</code>   on GitLab Community Edition)</li> </ul>"},{"location":"changelog/#v091_-_2019-09-23","title":"v0.9.1 - (2019-09-23)","text":"<ul> <li>Improve error message when <code>tsrc foreach</code> fails to start the process. Suggested by @dlewis-ald in #163</li> <li>Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165</li> </ul>"},{"location":"changelog/#v090_-_2019-08-13","title":"v0.9.0 - (2019-08-13)","text":"<ul> <li>Add support for GitHub Enterprise: patch by @sdavids13.</li> <li>Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the <code>tsrc</code> configuration file. Fix #158</li> <li>Fix crash when running <code>tsrc status</code> on a workspace with missing repositories (#160) - reported by @blastrock</li> </ul>"},{"location":"changelog/#v080_-_2019-08-12","title":"v0.8.0 - (2019-08-12)","text":"<ul> <li>Implement <code>tsrc sync --force</code>. Currently all it does is running <code>git fetch --force</code> on all repositories. Use with caution. See #152 for details.</li> </ul>"},{"location":"changelog/#v071_-_2019-08-02","title":"v0.7.1 - (2019-08-02)","text":"<ul> <li>Fix crash in <code>tsrc sync</code> when the <code>repo</code> configuration in the manifest contained neither an URL nor a remote. <code>tsrc</code> now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86)</li> </ul>"},{"location":"changelog/#v070_2019-07-08","title":"v0.7.0 (2019-07-08)","text":"<ul> <li>Add a <code>--file</code> option to <code>tsrc init</code> so that manifest can be read from   a custom path in the file system</li> <li>Remove support for Python 3.4</li> <li>Switch from <code>xdg</code> to <code>pyxdg</code></li> <li>Format the code with black</li> </ul>"},{"location":"changelog/#v066_2019-04-02","title":"v0.6.6 (2019-04-02)","text":"<ul> <li>Remove raw HTML from README.rst</li> </ul>"},{"location":"changelog/#v065_2019-04-0","title":"v0.6.5 (2019-04-0)","text":"<ul> <li>Use <code>codecov.io</code> to measure coverage</li> <li>Prettify README</li> </ul>"},{"location":"changelog/#v064_2019-01-07","title":"v0.6.4 (2019-01-07)","text":"<ul> <li>Remove support for Python 3.3.</li> <li>Use new and shiny cli-ui package instead of old <code>python-cli-ui</code>.</li> </ul>"},{"location":"changelog/#v063_2018-11-04","title":"v0.6.3 (2018-11-04)","text":"<ul> <li>GitHub organization is now <code>TankerHQ</code></li> <li>We now use dmenv for dependencies management</li> </ul>"},{"location":"changelog/#v062_2018-10-19","title":"v0.6.2 (2018-10-19)","text":"<p>Fix crash when using <code>tsrc push</code> on a GitHub repository for the first time.</p>"},{"location":"changelog/#v061_2018-10-10","title":"v0.6.1 (2018-10-10)","text":"<p>Fix weird output when configuring remotes.</p>"},{"location":"changelog/#v060_2018-10-09","title":"v0.6.0 (2018-10-09)","text":""},{"location":"changelog/#add_support_for_multiple_remotes","title":"Add support for multiple remotes","text":"<pre><code># still valid (implicit 'origin' remote)\nsrc: foo\nurl: git@github.com/foo\n\n# also valid (two explicit remotes)\nsrc: foo\nremotes:\n  - { name: origin, url: git@github.com:john/foo }\n  - { name: upstream, url: git@github.com:foo/foo}\n\n# not valid (ambiguous)\nsrc: foo\nurl: git@github.com:john/foo\nremotes:\n   - { name: upstream, url: git@github.com:foo/foo }\n</code></pre> <p>Thanks @tst2005 and @cgestes for their help with the configuration format.</p>"},{"location":"changelog/#tsrc_foreach","title":"tsrc foreach","text":"<ul> <li><code>tsrc foreach</code>: add a <code>--group</code> option to select the repositories to run the command on. Fix #40</li> </ul>"},{"location":"changelog/#other_fixes_1","title":"Other fixes","text":"<ul> <li>Fix #113: do not hide branch when showing tag status.</li> <li>Add support for Python 3.7</li> </ul>"},{"location":"changelog/#v050_2018-08-14","title":"v0.5.0 (2018-08-14)","text":"<ul> <li>Add support for setting approvers with the <code>-r,--approvers</code> option in <code>tsrc push</code> (GitLab Enterprise Edition only).</li> </ul>"},{"location":"changelog/#v041_2018-04-27","title":"v0.4.1 (2018-04-27)","text":"<ul> <li>Fixed regression: <code>tsrc push</code> was no longer able to create a merge request on GitLab if <code>--target</code> was not set.</li> </ul>"},{"location":"changelog/#v040_2018-04-26","title":"v0.4.0 (2018-04-26)","text":""},{"location":"changelog/#highlights_2","title":"Highlights","text":"<ul> <li>Preliminary GitHub support</li> <li><code>tsrc push</code>: new features and bug fixes</li> <li>Improved fixed reference handling</li> <li>Support for shallow clones</li> </ul> <p>See below for the details.</p>"},{"location":"changelog/#preliminary_github_support","title":"Preliminary GitHub support","text":"<ul> <li>Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using <code>tsrc</code> from a repository which has a URL starting with <code>git@github.com</code>.</li> </ul> <p><code>tsrc</code> will prompt you once for your login and password and then store an API token.</p> <p>Afterwards, you'll be able to use <code>tsrc</code> push to:</p> <ul> <li>Create a pull request (or update it if it already exists)</li> <li>Assign people to the request (with the <code>-a/--assignee</code> option)</li> <li>Request reviewers (with the <code>--reviewers</code> option)</li> <li>Merge the pull request (with the <code>--merge</code> option)</li> </ul> <p>This change has no impact if you were already using <code>GitLab</code>.</p>"},{"location":"changelog/#tsrc_push_new_features_and_bug_fixes","title":"<code>tsrc push</code>: new features and bug fixes","text":"<ul> <li>Add <code>--close</code> option.</li> <li>Breaking change: <code>-m/--message</code> option is gone, use <code>--title</code> instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title, so it had to be renamed.</li> <li>Do not assume local and remote tracking branch have the same name.</li> <li>Allow using <code>tsrc push &lt;local&gt;:&lt;remote&gt;</code> to explicitly specify local and remote branch names.</li> <li>Fix bugs when target is not specified on the command line. See this commit for details.</li> <li>Fix missing merge requests in <code>tsrc push</code> (see issue #80). Patch by @maximerety.</li> </ul>"},{"location":"changelog/#improve_fixed_reference_handling","title":"Improve fixed reference handling","text":"<p>Breaking change: Instead of using <code>fixed_ref</code> in the manifest, you should now use <code>tag</code> or <code>sha1</code>:</p> <p>old: <pre><code>repos:\n  - src: git@example.com/foo\n    fixed_ref: 42a70\n</code></pre></p> <p>new: <pre><code>repos:\n  - src: git@example.com/foo\n    tag: v0.1\n</code></pre></p> <p>See the dedicated section about manifest format and the #57 pull request discussion for the details.</p> <p>This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1.</p>"},{"location":"changelog/#support_for_shallow_clones","title":"Support for shallow clones","text":"<p>To save time and space, you can use <code>tsrc init --shallow</code> to only have shallow clones in your workspace.</p> <p>Note that due to limitations in <code>git</code> itself, the <code>shallow</code> option cannot be used with a fixed SHA1. If you need this, prefer using a <code>tag</code> instead.</p>"},{"location":"changelog/#misc_2","title":"Misc","text":"<ul> <li> <p>Organization <code>TankerApp</code> was renamed to <code>TankerHQ</code>. New urls are:</p> <ul> <li>github.com/TankerHQ/tsrc for the git repository</li> <li>TankerHQ.github.io/tsrc for the documentation</li> </ul> </li> <li> <p>We now use pipenv for dependency handling.</p> </li> </ul>"},{"location":"changelog/#v032_2017-11-02","title":"v0.3.2 (2017-11-02)","text":"<ul> <li>Improve <code>tsrc status</code> to handle tags. Patch by @arnaudgelas.</li> <li>Fix crash when running <code>tsrc version</code>.</li> </ul>"},{"location":"changelog/#v031_2017-10-06","title":"v0.3.1 (2017-10-06)","text":"<ul> <li>Improve <code>tsrc status</code> output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas.</li> </ul>"},{"location":"changelog/#v030_2017-09-22","title":"v0.3.0 (2017-09-22)","text":"<p>Breaking change: Add support for groups (#30). Reported by @arnaudgelas.</p> <p>See the dedicated section about manifest format for details.</p> <p>Upgrading from v0.2.4:</p> <p>To upgrade from an older version of <code>tsrc</code>, you should re-run <code>tsrc init</code> with the correct url:</p> <pre><code># Check manifest URL:\n$ cd &lt;workspace&gt;/.tsrc/manifest\n$ git remote get-url origin\n# Note the url, for instance ssh://git@example.com:manifest.git\n$ cd &lt;workspace&gt;\n$ tsrc init &lt;manifest-url&gt;\n</code></pre> <p>This is required to create the <code>&lt;workspace&gt;/.tsrc/manifest.yml</code> file which is later used by <code>tsrc sync</code> and other commands.</p>"},{"location":"changelog/#v024_2017-07-13","title":"v0.2.4 (2017-07-13)","text":"<ul> <li><code>tsrc push --assignee</code>: fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas</li> </ul>"},{"location":"changelog/#v023_2017-09-01","title":"v0.2.3 (2017-09-01)","text":"<ul> <li> <p>Split user interface functionality into its own project: python-cli-ui.</p> </li> <li> <p>Add <code>--quiet</code> and <code>--color</code> global options.</p> </li> </ul>"},{"location":"changelog/#v022_2017-08-22","title":"v0.2.2 (2017-08-22)","text":"<p>Bug fix release.</p> <ul> <li><code>tsrc init</code>: Fix crash when a repository is empty (#17). Reported by @nicolasbrechet</li> <li><code>tsrc push</code>: Fix rude message when credentials are missing (#20). Reported by @cgestes</li> </ul>"},{"location":"changelog/#v021_2017-08-10","title":"v0.2.1 (2017-08-10)","text":"<p>Packaging fixes.</p>"},{"location":"changelog/#v020_2017-08-09","title":"v0.2.0 (2017-08-09)","text":"<ul> <li>Support for specifying custom branches in the manifest</li> <li>Support for specifying fixed refs (tags or hashes) in the manifest</li> </ul> <p>New syntax is:</p> <pre><code>repos:\n  - src: foo\n    url: git@gitlab.com:proj/foo\n    branch: next\n\n  - src: bar\n    url: git@gitlab.com:proj/bar\n    branch: master\n    fixed_ref: v0.1\n</code></pre> <p>Note that <code>branch</code> is still required.</p> <ul> <li>You can now skip the <code>dest</code> part of the <code>copy</code> section if <code>src</code> and <code>dest</code> are   equal:</li> </ul> <pre><code>copy:\n  - src:foo\n\n# same thing as\ncopy:\n - src: foo\n   dest: foo\n</code></pre>"},{"location":"changelog/#v014_2017-08-04","title":"v0.1.4 (2017-08-04)","text":"<p>Support for Python 3.3, 3.4, 3.5 and 3.6</p>"},{"location":"changelog/#v011_2017-08-02","title":"v0.1.1 (2017-08-02)","text":"<p>First public release</p>"},{"location":"code-manifesto/","title":"Code Manifesto","text":""},{"location":"code-manifesto/#basics","title":"Basics","text":"<p>We use <code>black</code> to enforce a coding style matching PEP8.</p> <p>In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set <code>core.autocrlf</code> to <code>true</code> in your git config file.)</p>"},{"location":"code-manifesto/#pet_peeves","title":"Pet peeves","text":"<ul> <li>Prefer double quotes for string literals:</li> </ul> <pre><code># Yes\ndef bar():\n   \"\"\" bar stuff \"\"\"\n   a = \"foo\"\n\n\n# No\ndef bar():\n   ''' bar stuff '''\n   a = 'foo'\n\n# Exception\nmy_str = 'It contains some \"quotes\" inside'\n</code></pre> <ul> <li> <p>Use the fact that empty data structures are falsy: <pre><code># Yes\nif not errors:\n    ...\n# No\nif len(errors) == 0:\n    ...\n</code></pre></p> </li> <li> <p>Avoid using double negatives: <pre><code># Yes\ndef make_coffee(sugar=False):\n    if sugar:\n        print(\"with sugar\")\n\n# No\ndef make_coffee(without_sugar=True):\n    if not without_sugar:\n        print(\"with sugar\")\n</code></pre></p> </li> <li> <p>Prefer using  \"f-strings\" if possible, <code>+</code> may also work in some contexts.</p> </li> </ul> <pre><code># Yes\nmessage = f\"Welcome {name}!\"\n\n# No\nmessage = \"Welcome, {}!\".format(name)\nmessage = \"Welcome, %s!\" % name\nmessage = \"Welcome, \" + name + \"!\"\n\n# Okayish\nwith_ext = name + \".txt\"\n</code></pre> <ul> <li>Use <code>textwrap.dedent()</code> to build nice-looking multi-lines strings:</li> </ul> <pre><code># Yes\ndef foo():\n    long_message = textwrap.dedent(\"\"\"\\\n        first line\n        second line\n        third line\"\"\")\n\n# No\ndef foo():\n    long_message = \"\"\"\\\nfirst line\nsecond line\nthird line\n\"\"\"\n</code></pre> <ul> <li>Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory)</li> </ul> <pre><code># Yes\nok, mess  = run_command()\n\nfor test_result in test_results:\n    outcome, message = res\n\n# No\nfoo, bar = False, \"\"\n\nclass Foo:\n    self.bar, self.baz = None, True\n</code></pre> <ul> <li>Do not use conditional expressions. The order is not the same as the ternary operator in C++ and JavaScript, so it should be avoided:</li> </ul> <pre><code># Yes\nif foo:\n   a = \"ok\"\nelse:\n   a = \"nope\"\n\n\n# No:\na = \"ok\" if foo else \"nope\"\n</code></pre> <ul> <li>Use <code>if ... in ...</code> when you can:</li> </ul> <pre><code># Yes\nif value in (\"option1\", \"option2\"):\n   ...\n\n# No\nif value == \"option1\" or value == \"option2\"\n  ...\n</code></pre>"},{"location":"code-manifesto/#doc_strings_and_comments_in_production_code","title":"Doc strings and comments in production code","text":"<p>First off, bad comments are worse that no comments.</p> <p>Also note that you should use comments to explain why, never what. If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead.</p> <p>In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful.</p> <p>Note: this does not apply for tests (see below).</p>"},{"location":"code-manifesto/#collections","title":"Collections","text":"<ul> <li>Use .extend() instead of += to concatenate lists:</li> </ul> <p><pre><code># Yes\nlist_1.extend(list_2)\n\n# No\nlist_1 += list_2\n</code></pre> * Only use <code>list()</code> and <code>dict()</code> to convert a value to a list or dict. Prefer literals when possible</p> <pre><code># Yes\nmy_list = []\nmy_dict = {}\n\n# Also yes:\nmy_list = list(yield_stuff())\n\n# No\nmy_list = list()\nmy_dict = dict()\n</code></pre> <ul> <li>Also use explicit call to list() in order to make a copy:</li> </ul> <pre><code># Yes\nmy_copy = list(my_list)\n\n# Also yes:\nmy_copy = copy.copy(my_list)\n\n# No\nmy_copy = my_list[:]\n</code></pre> <ul> <li>Use list comprehensions instead of loops and \"functional\" methods:</li> </ul> <pre><code># Yes\nmy_list = [foo(x) for x in other_list]\n\n# No\nmy_list = list()\nfor x in other_list:\n     x.append(foo(x))\n\n# Also no\nmy_list = map(foo, other_list)\n\n# Yes\neven_nums = [x for x in nums if is_even(x)]\n\n# No\neven_nums = filter(is_even, nums)\n</code></pre> <ul> <li>Use iterable syntax instead of building an explicit list:</li> </ul> <pre><code># Yes\nmax(len(x) for x in my_iterable)\n\n# No\nmax([len(x) for x in my_iterable])\n</code></pre> <ul> <li>Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names:</li> </ul> <pre><code>for result in results:\n   # do something with result\n</code></pre>"},{"location":"code-manifesto/#functions","title":"Functions","text":"<p>Prefer using keyword-only parameters when possible:</p> <pre><code># Yes\n# If the parameter needs a default value:\ndef foo(bar, *, spam=True):\n    ...\n\n# If it does not:\ndef foo(bar, *, spam):\n    ...\n\n\n# No\ndef foo(bar, spam=True):\n    ...\n</code></pre> <p>If you use the last form, Python will let you use <code>foo(42, False)</code>, and set <code>spam</code> to False. This can cause problems if someone ever changes the <code>foo</code> function and adds a new optional argument before <code>spam</code>:</p> <p><pre><code>def foo(bar, eggs=False, spam=True):\n    ...\n</code></pre> After such a change, the line <code>foo(42, False)</code> which used to call <code>foo</code> with <code>spam=False</code> now calls <code>foo</code> with <code>bar=False</code> and <code>spam=True</code>, leading to all kinds of interesting bugs.</p> <p>Exception to this rule: when the keyword is obvious and will not change: <pre><code>def get(value, default=None):\n  ...\n</code></pre></p>"},{"location":"code-manifesto/#imports","title":"Imports","text":"<p>For any <code>foo.py</code> file, <code>import foo</code> must never fail, unless there is a necessary module that could not be found. Do not catch  <code>ImportError</code> unless it is necessary, for instance to deal with optional dependencies.</p> <pre><code>import required_module\n\nHAS_NICE_FEATURE = True\ntry:\n    import nice_lib\nexcept ImportError:\n    HAS_NICE_FEATURE = False\n\n#...\n\nif HAS_NICE_FEATURE:\n    #....\n</code></pre> <ul> <li> <p>Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a <code>if __name__ == main() block</code>.</p> </li> <li> <p>Prefer using fully-qualified imports and names:</p> </li> </ul> <pre><code># Yes\nimport foo.bar\nmy_bar = foo.bar.Bar()\n\n# No\nfrom foo import bar\nmy_bar = bar.Bar()\n</code></pre> <p>Note</p> <p>We allow a few exceptions like <code>from pathlib import Path</code> or importing classes directory in tests. Use your best judgment.</p>"},{"location":"code-manifesto/#classes","title":"Classes","text":"<ul> <li>When you want to make sure a class follows an interface, use <code>abc.ABCMeta</code> instead of raising <code>NotImplementedError</code>. This way you get the error when the class is instantiated instead of when the method is called.</li> </ul> <pre><code># Yes\nclass AbstractFoo(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def foo(self):\n        pass\n\n\n# No\nclass AbstractFoo:\n     def foo(self):\n        raise NotImplementedError()\n</code></pre> <ul> <li>Make sure to use properties when relevant, instead of <code>get_</code> methods.</li> </ul> <pre><code># Yes\nclass Person:\n      def __init__(self, first_name, last_name):\n            self.first_name = first_name\n            self.last_name = last_name\n\n      @property\n      def full_name(self):\n          return f\"{self.first_name} {self.last_name}\"\n\n\n# No:\nclass Foo:\n      def __init__(self, first_name, last_name):\n            self.first_name = first_name\n            self.last_name = last_name\n            self.full_name = f\"{self.first_name} {self.last_name}\"\n</code></pre> <p>For instance, here:</p> <ul> <li><code>full_name</code> is read-only</li> <li>The attribute is automatically updated if <code>first_name</code> changes after the object is initialized.</li> </ul> <p>Note that <code>get_</code> methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...)</p>"},{"location":"code-manifesto/#file_paths","title":"File paths","text":"<ul> <li>If you are manipulating filenames, use the <code>path.py</code>library and suffix the variable by <code>_path</code>. Avoid using <code>os.path</code> or <code>shutil</code> methods when <code>path.py</code> is better.</li> </ul> <pre><code># Yes\nwork_path = Path(\"foo/work\")\nwork_path.mkdir_p()\nfoo_path = work_path / \"foo.txt\"\nfoo_path.write_text(\"this is bar\")\n\n# No\nwork_path = os.path.join(foo, \"work\")\nos.path.mkdir(work_path, exist_ok=True)\nfoo_path = os.path.join(work_path, \"foo.txt\")\nwith open(foo_path, \"w\") as fileobj:\n    fileobj.write(\"this is foo\")\n</code></pre>"},{"location":"code-manifesto/#error_handling","title":"Error handling","text":"<ul> <li>All exceptions raised from within <code>tsrc</code> should derive from <code>tsrc.Error</code>.</li> <li>When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them.</li> </ul>"},{"location":"code-manifesto/#output_messages_to_the_user","title":"Output messages to the user","text":"<p>Do not use <code>print</code>, use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away <code>print</code> statements you add for debugging.</p> <p>Also, using \"high-level\" methods such as <code>ui.info_1()</code> or <code>ui.warning()</code> will make it easier to have a consistent user interface.</p>"},{"location":"code-manifesto/#tests","title":"Tests","text":""},{"location":"code-manifesto/#docstrings","title":"Docstrings","text":"<p>If you think the test implementation is complex, add a human-readable description of the test scenario in the doc string.</p> <p>For instance:</p> <pre><code>def test_sync_with_errors(...):\n    \"\"\"\" Scenario:\n    * Create a manifest with two repos (foo and bar)\n    * Initialize a workspace from this manifest\n    * Push a new file to the foo repo\n    * Create a merge conflict in the foo repo\n    * Run `tsrc sync`\n    * Check that the command fails and produces the proper error message\n    \"\"\"\n</code></pre>"},{"location":"code-manifesto/#assertions_with_lists","title":"Assertions with lists","text":"<ul> <li>Use tuple unpacking to write shorter assertions:</li> </ul> <pre><code># Yes\nactual_list = function_that_returns_list()\n(first, second) = actual_list\nassert first == something\nassert second == something_else\n\n# NO\nactual_list = function_that_returns_list()\nassert len(actual_list) == 2\nfirst = actual_list[0]\nsecond = actual_list[1]\nassert first == something\nassert second == something_else\n</code></pre>"},{"location":"code-manifesto/#assertion_order","title":"Assertion order","text":"<p>When writing assertions, use the form <code>assert &lt;actual&gt; == &lt;expected&gt;</code>:</p> <pre><code># Yes\ndef test_foo():\n    assert foo(42) == True\n\ndef test_big_stuff():\n    actual_result = ...\n    expected_result = ...\n\n    assert actual_result == expected_result\n\n\n# No\ndef test_foo():\n    assert True == foo(42)\n\n\ndef test_big_stuff():\n    actual_result = ...\n    expected_result = ...\n\n    assert expected_result == actual_result\n</code></pre> <p>Rationale:</p> <ul> <li>The <code>assert(expected, actual)</code> convention comes from JUnit but we are not writing Java code,   and besides, the <code>assert(actual, expected)</code> convention also exists in other tools.</li> <li><code>pytest</code> does not really care, but we prefer being consistent in all tests.</li> <li>It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\".</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what_does_the_name_mean","title":"What does the name mean?","text":"<p>The <code>t</code> stands for <code>tool</code> and <code>src</code> for <code>sources</code>.</p> <p>If you speak French, you can also remember the name as \"tes sources\".</p>"},{"location":"faq/#why_not_repo","title":"Why not repo?","text":"<p>We used repo for a while, but found that tsrc had both a better command line API and a nicer output.</p> <p>On a less subjective level:</p> <ul> <li> <p>Good support for Windows (no need for Cygwin or anything like that)</p> </li> <li> <p>Also, tsrc tries hard to never do any destructive operation or unexpected   actions.</p> <p>For instance, <code>tsrc</code> never puts you in a \"detached HEAD\" state, nor does automatic rebase. It also never touches dirty repositories.</p> <p>This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals.</p> </li> </ul> <p>Also (and this matters a lot if you think about contribution):</p> <ul> <li>Uses PEP8 coding style, enforced with <code>black</code></li> <li>Comprehensive test suite</li> <li>Fully type-checked with <code>mypy</code></li> </ul> <p>Note that there are a few features present in <code>repo</code> that are missing from <code>tsrc</code> (but may be implemented in the future). Feel free to open a feature request if needed!</p>"},{"location":"faq/#why_not_git-subrepo_mu-repo_or_gr","title":"Why not git-subrepo, mu-repo, or gr?","text":"<p>All this projects are fine but did not match our needs:</p> <ul> <li>git-subrepo squashes commits, and   we prefer having normal clones everywhere.</li> <li>mu-repo is nice and contains an   interesting dependency management feature, but currently we do not need this complexity.</li> </ul> <p>In any case, now that the whole team is using <code>tsrc</code> all the time, it's likely we'll keep using <code>tsrc</code> in the future.</p>"},{"location":"faq/#why_not_git_submodule","title":"Why not git submodule?","text":"<p>It's all about workflow.</p> <p>With <code>git-submodule</code>, you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit.</p> <p>It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want.</p> <p>With <code>tsrc</code>, all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories.</p> <p>For instance, if you have <code>foo</code> and <code>bar</code>, you are going to make sure the 'master' branch of <code>foo</code> is always compatible to the 'master' branch of <code>bar</code>.</p> <p>Or if you want to go back to the state of the '0.42' release, you will run: <code>tsrc foreach -- git reset --hard v0.42</code>.</p> <p>Note that since <code>tsrc 0.2</code> you can also freeze the commits of some of the repositories.</p> <p>Last but not least, if you really need to use fixed references, you may do so by adding a <code>sha1</code> or <code>tag</code> line to the manifest. See the relevant guide for more details.</p>"},{"location":"faq/#why_not_using_pygit2_or_similar_instead_of_running_git_commands","title":"Why not using pygit2 or similar instead of running git commands?","text":"<p>First off, we do use <code>pygit2</code>, but only for tests.</p> <p>Second, the <code>pygit2</code> package depends on a 3rd party C library (<code>libgit2</code>) - and that can cause problems in certain cases. If we can, we prefer using pure-Python libraries for the production code.</p> <p>Finally, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging (see below).</p>"},{"location":"faq/#why_do_you_hide_which_git_commands_are_run","title":"Why do you hide which git commands are run?","text":"<p>It's mainly a matter of not cluttering the output. We take care of keeping the output of <code>tsrc</code> both concise, readable and informative.</p> <p>That being said:</p> <ul> <li>In case a git command fails, we'll display the full command that was run.</li> <li>If you still need to see all the git commands that are run, we provide a   <code>--verbose</code> flag, like so: <code>tsrc --verbose sync</code></li> </ul>"},{"location":"faq/#why_yaml","title":"Why YAML?","text":"<p>It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support.</p> <p>Also, being Python fans, we don't mind that white space is part of the syntax.</p>"},{"location":"faq/#why_do_i_have_to_create_a_separate_git_repo_with_just_one_file_in_it","title":"Why do I have to create a separate git repo with just one file in it?","text":"<p>See #235 for why you can't have multiple manifest files in the same repository.</p> <p>Also, note that you can put other files in the repo - for instance, add a CI script that verifies the yaml syntax and checks that all the repos in the manifest can be cloned.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>Python 3.7 or later</p>"},{"location":"getting-started/#installing_tsrc","title":"Installing tsrc","text":"<p>The recommended way to install <code>tsrc</code> is to use pipx. This is because <code>pipx</code> automatically creates isolated environment for each app, so you won't get into dependencies versions conflicts and won't have to deal with manual virtualenvs management. </p> <p><code>pip</code> will also work, but it will not give you these benefits.</p> <p>Recommended: <pre><code>pipx install tsrc\n</code></pre></p> <p>Acceptable, if you know what you are doing: <pre><code>pip install tsrc\n</code></pre></p>"},{"location":"getting-started/#checking_tsrc_installation","title":"Checking tsrc installation","text":"<p>Run:</p> <pre><code>$ tsrc --version\n</code></pre>"},{"location":"getting-started/#creating_a_repository_for_the_manifest","title":"Creating a repository for the manifest","text":"<p>Let's say you are working for the ACME company and you have many git repositories.</p> <p>You need a tool to track them, so that if a new repository is created, all developers can get a clone on their development machine quickly, without having to look up its URL or even know it exists.</p> <p>Also, you need to make sure the repos are cloned in a certain way, so that you can for instance refer a repo from an other one by using a relative path.</p> <p>This is where <code>tsrc</code> comes in.</p> <p>The first step is to create a dedicated repository for the manifest. I know it may sound wasteful (\"I have already 100 repositories to manage, and you want me to create yet an other one?\"), but, trust me, it's worth it.</p> <p>So, if your company uses a GitLab instance at <code>gitlab.acme.com</code> and you want to crate a manifest for your team, you may start by creating a new repository at <code>https://gitlab.acme.com/your-team/manifest</code>.</p> <p>Inside this repository, create a file named <code>manifest.yml</code> looking like this:</p> <pre><code>repos:\n  - dest: foo\n    url: git@gitlab.acme.com/your-team/foo\n\n  - dest: bar\n    url: git@gitlab.acme.com/your-team/bar\n</code></pre> <p>Note that this approach works with any king of Git Hosting system, not just a custom GitLab instance. Just replace <code>gitlab.acme.com/your-team</code> with the correct suffix (like <code>github.com/your-name/</code> if you want to track some repositories from your GitHub account).</p>"},{"location":"getting-started/#creating_a_new_workspace","title":"Creating a new workspace","text":"<p>Create a new, empty directory and then run <code>tsrc init</code> from it, using the URL of the manifest created in the above step:</p> <pre><code>$ mkdir work\n$ cd work\n$ tsrc init git@gitlab.acme.com/your-team/manifest.git\n</code></pre> <p>You should see something like this:</p> <pre><code>:: Configuring workspace in /path/to/work\nCloning into 'manifest'...\n...\n=&gt; Cloning missing repos\n* (1/2) Cloning foo\nCloning into 'foo'...\n...\n* (2/2) Cloning bar\nCloning into 'bar'...\n...\n=&gt; Cloned repos:\n* foo cloned from gt@gitlab.acme.com/your-team/foo' (on master)\n* bar cloned from gt@gitlab.acme.com/your-team/bar' (on master)\n=&gt; Configuring remotes\n=&gt; Workspace initialized\n=&gt; Configuration written in /path/to/work/.tsrc/config.yml\n</code></pre> <p>You will notice that:</p> <ul> <li>The <code>foo</code> ad <code>bar</code> repositories have been cloned into their respective destination</li> <li>A workspace configuration file has been created in <code>/path/to/work/.tsrc/config.yml</code>. This   file can be edited by hand to customize <code>tsrc</code> behavior. Follow the relevant guide,   or read the workspace configuration file reference for more details.</li> </ul>"},{"location":"getting-started/#updating_a_new_workspace","title":"Updating a new workspace","text":"<p>Now let's assume that Alice created a new commit in <code>foo</code>, and Bob a new commit it <code>bar</code>, and that they both pushed them to the <code>master</code> branch of the respective repositories.</p> <p>Now that you have a workspace configured with <code>tsrc</code>, you can use <code>tsrc sync</code> to retrieve all the changes in one go:</p> <pre><code>$ cd work\n$ tsrc sync\n</code></pre> <p>This time, you should see the following output:</p> <pre><code>:: Using workspace in /path/to/work\n=&gt; Updating manifest\n...\n=&gt; Cloning missing repos\n=&gt; Configuring remotes\n=&gt; Synchronizing repos\n* (1/2) Synchronizing foo\n* Fetching origin\n...\n   f20af74..aca6c35  master     -&gt; origin/master\n* Updating branch: master\nUpdating f20af74..aca6c35\nFast-forward\n new.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 new.txt\n* (2/2) Synchronizing bar\n* Fetching origin\n...\n   f20af74..02cfef6  master     -&gt; origin/master\n* Updating branch: master\nUpdating f20af74..02cfef6\nFast-forward\n spam.py | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 spam.py\n:: Workspace synchronized\n</code></pre> <p>Note: <code>tsrc sync</code> does not call <code>git pull</code> on every repository. The precise algorithm is described in the reference documentation</p>"},{"location":"getting-started/#adding_a_new_repo_to_the_manifest","title":"Adding a new repo to the manifest","text":"<p>Let's say your team now needs a third repository (for instance, at <code>gitlab.acme.com/your-team/baz</code>).</p> <p>Start by making a commit in the <code>manifest</code> repository that adds the new repository:</p> <pre><code>--- a/manifest.yml\n+++ b/manifest.yml\n@@ -1,2 +1,3 @@\n repos:\n   - dest: foo\n     url: git@gitlab.acme.com/your-team/foo\n\n   - dest: bar\n     url: git@gitlab.acme.com/your-team/baz\n\n+  - dest: baz\n+    url: git@gitlab.acme.com/your-team/baz\n</code></pre> <p>Then push this commit to the <code>master</code> branch of the manifest.</p> <p>This time when you run <code>tsrc sync</code>:</p> <ul> <li>the <code>manifest</code> repository will get updated</li> <li>the <code>baz</code> repo will be cloned in <code>/path/to/work/baz</code></li> </ul> <pre><code>$ tsrc sync\n</code></pre> <pre><code>:: Using workspace in /path/to/work\n=&gt; Updating manifest\nremote: Enumerating objects: 5, done.\n...\nUnpacking objects: 100% (3/3), 354 bytes | 354.00 KiB/s, done.\nFrom gitlab.acme.com/your-team/manifest\n   63f12d4..bbcd4d9  master     -&gt; origin/master\nReset branch 'master'\n...\nHEAD is now at bbcd4d9 add baz\n\n=&gt; Cloning missing repos\n* (1/1) Cloning baz\nCloning into 'baz'...\n...\nReceiving objects: 100% (3/3), done.\n=&gt; Cloned repos:\n* baz cloned from git@gitlab.acme.com/bas (on master)\n=&gt; Configuring remotes\n=&gt; Synchronizing repos\n* (1/3) Synchronizing foo\n* Fetching origin\n* Updating branch: master\nAlready up to date.\n* (2/3) Synchronizing bar\n* Fetching origin\n* Updating branch: master\nAlready up to date.\n* (3/3) Synchronizing baz\n* Fetching origin\n* Updating branch: master\nAlready up to date.\n:: Workspace synchronized\n</code></pre>"},{"location":"getting-started/#going_further","title":"Going further","text":"<p>In this tutorial, we made a lot of assumptions:</p> <ul> <li>Every repository is using the <code>master</code> as the main development branch</li> <li>Each repository as only one git remote (the one from <code>gitlab.acme.com</code> in our example)</li> <li>You're using a manifest just for your team, not the whole company</li> <li>...</li> </ul> <p><code>tsrc</code> can handle all of this use cases, and more. See the other guides for more details.</p>"},{"location":"contrib/dev/","title":"Suggesting changes","text":"<p>All the development happens on GitHub.</p> <p>You are free to open a pull request for anything you want to change on <code>tsrc</code>.</p> <p>In particular, pull requests that implement a prototype for a new feature are welcome, having \"real code\" to look at can provide useful insight, even if the code is not merged after all.</p> <p>That being said, if you want your pull request to be merged, we'll ask that:</p> <ul> <li>The code follows the indications from the code manifesto</li> <li>All existing linters pass</li> <li>All existing tests run</li> <li>The new feature comes with appropriate tests</li> <li>The Git History is easy to review</li> </ul> <p>See the GitHub actions workflows to see what exactly what commands are run and the Python versions we support.</p> <p>Also, if relevant, you will need to:</p> <ul> <li>update the changelog (in <code>docs/changelog.md</code>)</li> <li>update the documentation if required</li> </ul> <p>Finally, feel free to add your name in the <code>THANKS</code> file ;)</p>"},{"location":"contrib/dev/#checking_your_changes","title":"Checking your changes","text":"<ul> <li>Install latest poetry version.</li> <li>Install development and documentation dependencies:</li> </ul> <pre><code>$ poetry install\n</code></pre> <ul> <li>Run linters and tests:</li> </ul> <pre><code>$ poetry run invoke lint\n$ poetry run pytest -n auto\n</code></pre>"},{"location":"contrib/dev/#adding_documentation","title":"Adding documentation","text":"<ul> <li>Follow the steps from the above section to setup your python environment</li> <li>Launch the development server locally:</li> </ul> <pre><code>$ poetry run mkdocs serve\n</code></pre> <ul> <li>Edit the markdown files from the <code>docs/</code> folder and review the changes in your browser</li> <li>Finally, submit your changes by opening a pull request on GitHub</li> </ul>"},{"location":"contrib/issues/","title":"Using the issue tracker","text":"<p>Reporting bugs and requesting new features is done one the tsrc issue tracker on GitHub.</p>"},{"location":"contrib/issues/#reporting_bugs","title":"Reporting bugs","text":"<p>If you are reporting a bug, please provide the following information:</p> <ul> <li><code>tsrc</code> version</li> <li>Details about your environment (operating system, Python version)</li> <li>The exact command you run</li> <li>The full output</li> </ul> <p>Doing so will ensure we can investigate your bug right away.</p>"},{"location":"contrib/issues/#suggesting_new_features","title":"Suggesting new features","text":"<p>If you think <code>tsrc</code> is lacking a feature, please provide the following information:</p> <ul> <li>What exactly is your use case?</li> <li>Do you need a new command-line option or even a new command?</li> <li>Do you need changes in the configuration files?</li> </ul> <p>Note that changing<code>tsrc</code> behavior can get tricky.</p> <p>First off, we want to avoid data loss following a <code>tsrc</code> command above</p> <p>Second, we want to keep <code>tsrc</code> behavior as least surprising as possible, so that it can be used without having to read (too much of) documentation.</p> <p>To that end, and keeping in mind <code>tsrc</code> needs to accommodate a large variety of use cases, we want to keep the code:</p> <ul> <li>easy to read and,</li> <li>easy to maintain,</li> <li>and very well tested.</li> </ul> <p>The best way to achieve all of this is to keep it simple.</p> <p>This means we'll be very cautious before implementing a new feature, so don't hesitate to open an issue for discussion before jumping into the development of a new feature.</p>"},{"location":"guide/ci/","title":"Using tsrc with Continuous Integration (CI)","text":""},{"location":"guide/ci/#github_actions","title":"GitHub Actions","text":"<p>Let suppose you have a private GitHub organization holding several private repositories and tsrc to synchronize them using the SSH protocol. Let suppose you want to use GitHub Actions to download the code source of your organization, compile it and run some non regression tests. What to write to achieve this with tsrc?</p>"},{"location":"guide/ci/#step_1_your_tsrc_manifest","title":"Step 1: Your tsrc manifest","text":"<p>Your tsrc <code>manifest.yml</code> looks something like this:</p> <pre><code>repos:\n  - url: git@github.com:project1/foo\n    dest: foo\n</code></pre> <p>The <code>git@</code> means SSH protocol.</p>"},{"location":"guide/ci/#step_2_create_your_github_workflows_file","title":"Step 2: Create your GitHub workflows file","text":"<p>In your private GitHub repository holding the GitHub workflows files, create the folder <code>.github/workflows</code> and your yaml file with the desired name and the following content. For more information about GitHub actions syntax see this video:</p> <pre><code>name: tsrc with private github repos\non:\n  workflow_dispatch:\n    branches:\n      - main\n\njobs:\n  export_linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Installing tsrc tool\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y python3\n        python -m pip install tsrc\n\n    - name: Cloning private github repos\n      run: |\n        git config --global url.\"https://${{ secrets.ACCESS_TOKEN }}@github.com/\".insteadOf git@github.com:\n        export WORKSPACE=$GITHUB_WORKSPACE/your_project\n        mkdir -p $WORKSPACE\n        cd $WORKSPACE\n        tsrc init git@github.com:yourorganisation/manifest.git\n        tsrc sync\n</code></pre> <p>This script will run on the latest Ubuntu Docker and triggers steps: - The first step named <code>Installing tsrc tool</code> allows to install python3 and then   tsrc. - The second step named <code>Cloning private github repos</code> creates a folder named   <code>your_project</code> for your workspace and call the initialization and   synchronization of your repositories.</p> <p>The important command is: <pre><code>git config --global url.\"https://${{ secrets.ACCESS_TOKEN }}@github.com/\".insteadOf git@github.com:\n</code></pre></p> <p>which allows to replace the SSH syntax by the HTTPs syntax on your GitHub repository names.</p>"},{"location":"guide/ci/#step_3_create_the_github_secret","title":"Step 3: Create the GitHub secret","text":"<p>For GitHub organization one member of the team has the responsibility to hold a <code>Personal access tokens</code> for the organization. Go https://github.com/settings/tokens and click on the button <code>Generate new token</code> then click on <code>repo</code> checkbox then click on the button <code>Generate token</code>.</p> <p>Now, this token shall be saved into an action secret named <code>ACCESS_TOKEN</code> inside the GitHub repository holding the GitHub workflows files.</p>"},{"location":"guide/ci/#step_4_enjoy","title":"Step 4: Enjoy","text":"<p>In the menu <code>Actions</code> of your repository you can trig the workflow. In this example we used <code>workflow_dispatch</code> to perform manual triggers. So click on the button to start the process. Once this step done with success, you can update your workflow yaml to complete your CI work: compilation of your project, run non regression tests, etc.</p>"},{"location":"guide/fixed-refs/","title":"Using fixed git references","text":"<p>By default, <code>tsrc sync</code> synchronize projects using branches names.</p> <p>Usually, one would use the same branch name for several git repositories, like this:</p> <pre><code>repos:\n  - dest: foo\n    url: git@gitlab.acme.com/your-team/foo\n    branch: main\n\n  - dest: bar\n    url: git@gitlab.acme.com/your-team/bar\n    branch: main\n</code></pre> <p>The assumption here is that <code>foo</code> and <code>bar</code> evolve \"at the same time\", so when the <code>main</code> branch of <code>foo</code> is updated, the <code>main</code> branch of <code>bar</code> much change too.</p> <p>Sometimes though, this will not be the case. For instance, the <code>main</code> branch of the <code>bar</code> repo needs a specific, fixed version of <code>foo</code> in order to work.</p>"},{"location":"guide/fixed-refs/#using_a_tag","title":"Using a tag","text":"<p>One way to solve this is to push a v1.0 tag in the <code>foo</code> repository, and change the manifest too look like this:</p> <pre><code>repos:\n  - dest: foo\n    url: git@gitlab.acme.com/your-team/foo\n-    branch: main\n+    tag: v1.0\n</code></pre>"},{"location":"guide/fixed-refs/#using_a_sha1","title":"Using a sha1","text":"<p>An other way is to put the SHA1 of the relevant git commit in the <code>foo</code> repository in the manifest:</p> <pre><code>repos:\n  - dest: foo\n    url: git@gitlab.acme.com/your-team/foo\n    branch: main\n+    sha1: ad2b68539c78e749a372414165acdf2a1bb68203\n</code></pre>"},{"location":"guide/fixed-refs/#cloning_repos_using_fixed_refs","title":"Cloning repos using fixed refs","text":"<ul> <li>If the repo is configured with a tag, <code>tsrc</code> will call <code>git clone   --branch &lt;tag&gt;</code> (which is valid)</li> <li>Otherwise, <code>tsrc</code> will call <code>git clone</code>, followed by <code>git reset --hard &lt;sha1&gt;</code></li> </ul> <p>This is because you cannot tell git to use an arbitrary git reference as start branch when cloning (tags are fine, but sha1s are not).</p> <p>This also explain why you need both <code>branch</code> and <code>sha1</code> in the configuration.</p>"},{"location":"guide/fixed-refs/#synchronizing_repos_using_fixed_refs","title":"Synchronizing repos using fixed refs","text":"<p>Here's what <code>tsrc sync</code> will do when trying to synchronize a repo configured with a fixed ref:</p> <ul> <li>Run <code>git fetch --tags --prune</code></li> <li>Check if the repository is clean</li> <li>If so, run <code>git reset --hard &lt;tag or sha1&gt;</code></li> </ul>"},{"location":"guide/foreach/","title":"Running a command for each repo in the workspace","text":"<p><code>tsrc</code> comes with a <code>foreach</code> command that allows you to run the same command for each repo in the workspace.</p> <p>This can be used for several things. For instance, if you are building an artifact from a group of repositories, you may want to put a tag on each repo that was used to produce it:</p> <pre><code>$ tsrc foreach git tag v1.2\n</code></pre> <pre><code>:: Using workspace in /path/to/work\n:: Running `git tag v1.1` on 2 repos\n/path/to/work/foo $ git tag v1.2\n/path/to/work/bar $ git tag v1.2\n/path/to/work/baz $ git tag v1.2\nOK \u2713\n</code></pre>"},{"location":"guide/foreach/#caveats","title":"Caveats","text":"<ul> <li>If the command you want to run contains arguments starting with\u00a0<code>-</code>: you need to call <code>foreach</code> like this:</li> </ul> <pre><code>$ tsrc foreach -- some-command --with-option\n</code></pre> <ul> <li>By default, the command is passed \"as is\", without starting a shell. If you want   to use a shell, use the <code>-c</code> option:</li> </ul> <pre><code>$ tsrc foreach -c  'echo $PWD'\n</code></pre> <p>Note that we need single quotes here to prevent the shell from expanding the <code>PWD</code> environment variable when <code>tsrc</code> is run.</p>"},{"location":"guide/foreach/#using_repo_and_manifest_data","title":"Using repo and manifest data","text":"<p>The current <code>tsrc</code> implementation may not contain all the features your organization needs.</p> <p>The good news is that you can extend <code>tsrc</code>'s feature set by using <code>tsrc foreach</code>.</p> <p>Let's take an example, where you have a manifest containing <code>foo</code> and <code>bar</code> and both repos are configured to use a <code>master</code> branch.</p> <p>Here's what happens if you run <code>tsrc sync</code> with <code>bar</code> on the correct branch (<code>master</code>), and <code>foo</code> on an incorrect branch (<code>devel</code>):</p> <pre><code>$ tsrc sync\n</code></pre> <pre><code>:: Using workspace in /path/to/work\n=&gt; Updating manifest\n...\n=&gt; Cloning missing repos\n=&gt; Configuring remotes\n=&gt; Synchronizing repos\n* (1/2) Synchronizing foo\n* Fetching origin\n* Updating branch: devel\nUpdating 702f428..2e4fb45\nFast-forward\n...\n* (2/2) Synchronizing bar\n* Fetching origin\n* Updating branch: master\nAlready up to date.\nError: Failed to synchronize the following repos:\n* foo : Current branch: 'devel' does not match expected branch: 'master'\n</code></pre> <p>If this happens with multiple repos, you may want a command to checkout the correct branch automatically.</p> <p>Here's one way to do it:</p> <pre><code>$ tsrc foreach -c 'git checkout $TSRC_PROJECT_MANIFEST_BRANCH'\n</code></pre> <p>Here we take advantage of the fact that <code>tsrc</code> sets the <code>TSRC_PROJECT_MANIFEST_BRANCH</code> environment variable correctly for each repository before running the command.</p> <p>Here's the whole list:</p> Variable Description <code>TSRC_WORKSPACE_PATH</code> Full path of the workspace root <code>TSRC_MANIFEST_BRANCH</code> Branch of the manifest <code>TSRC_MANIFEST_URL</code> URL of the manifest <code>TSRC_PROJECT_CLONE_URL</code> URL used to clone the repo <code>TSRC_PROJECT_DEST</code> Relative path of the repo in the workspace <code>TSRC_PROJECT_MANIFEST_BRANCH</code> Branch configured in the manifest for this repo <code>TSRC_PROJECT_REMOTE_&lt;NAME&gt;</code> URL of the remote named 'NAME' <code>TSRC_PROJECT_STATUS_DIRTY</code> Set to <code>true</code> if the project is dirty, otherwise unset <code>TSRC_PROJECT_STATUS_AHEAD</code> Number of commits ahead of the remote ref <code>TSRC_PROJECT_STATUS_BEHIND</code> Number of commits behind the remote ref <code>TSRC_PROJECT_STATUS_BRANCH</code> Current branch of the repo <code>TSRC_PROJECT_STATUS_SHA1</code> SHA1 of the current branch <code>TSRC_PROJECT_STATUS_STAGED</code> Number of files that are staged but not committed <code>TSRC_PROJECT_STATUS_NOT_STAGED</code> Number of files that are changed but not staged <code>TSRC_PROJECT_STATUS_UNTRACKED</code> Number of files that are untracked <p>You can implement more complex behavior using the environment variables above, for instance:</p> <pre><code>#!/bin/bash\n# in switch-and-pull\nif [[ \"${TSRC_PROJECT_STATUS_DIRTY}\" = \"true\" ]]; then\n  echo Error: project is dirty\n  exit 1\nfi\n\ngit switch $TSRC_PROJECT_MANIFEST_BRANCH\ngit pull\n</code></pre> <pre><code>$ tsrc foreach switch-and-pull\n:: Running `switch-and-pull` on 2 repos\n* (1/2) foo\n/path/to/foo $ switch-and-pull\nSwitched to branch 'master'\nYour branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.\n  (use \"git pull\" to update your local branch)\nUpdating 9e7a8e4..5f9bbd4\nFast-forward\n* (2/2) bar\n/path/to/bar $ switch-and-pull\nError: project is dirty\nError: Command failed for 1 repo(s)\n* bar\n</code></pre> <p>Of course, feel free to use your favorite programming language here :)</p>"},{"location":"guide/fs/","title":"Performing file system operations","text":""},{"location":"guide/fs/#introduction","title":"Introduction","text":"<p>When using <code>tsrc</code>, it is assumed that repositories are put in non-overlapping file system hierarchies, like this:</p> <pre><code>workspace/\n  project_1/\n   CMakeLists.txt\n    foo.cpp\n    bar.cpp\n  project_2/\n    CMakeLists.txt\n    spam.cpp\n    eggs.cpp\n</code></pre> <p>Not like that, where <code>project_2</code> is inside a sub-directory of <code>project_1</code>:</p> <pre><code>workspace/\n  project_1/\n    CMakeLists.txt\n    foo.cpp\n    bar.cpp\n    project_2/\n      CMakeLists.txt\n      spam.cpp\n      eggs.cpp\n</code></pre> <p>Note</p> <p>if you really need <code>project_2</code> to be a sub-directory of <code>project_1</code>, consider using git submodules instead.</p> <p>This is usually fine, except when <code>project_1</code> and <code>project_2</code> share some common configuration.</p> <p>For instance, you may want to use <code>clang-format</code> for both <code>project_1</code> and <code>project_2</code>.</p>"},{"location":"guide/fs/#copying_a_file","title":"Copying a file","text":"<p>One solution is to put the <code>.clang-format</code> configuration file in a repo named <code>common</code> and then tell <code>tsrc</code> to copy it at the root of the workspace:</p> <pre><code>repos:\n  - dest: project_1\n    url: git@acme.com:team/project_1\n\n  - dest: project_2\n    url: git@acme.com:team/project_2\n\n  - dest: common\n    url: git@acme.com:team/commont\n    copy:\n    - file: clang-format\n      dest: .clang-format\n</code></pre> <pre><code>$ tsrc sync\n=&gt; Cloning missing repos\n* (1/1) Cloning common\nCloning into 'common'...\n...\n=&gt; Performing filesystem operations\n* (1/1) Copy /path/to/work/common/clang-format -&gt; /path/to/work/.clang-format\n</code></pre> <p>Notes:</p> <ul> <li><code>copy</code> only works with files, not directories.</li> <li>The source path for a copy link is relative to associated repos destination, whereas   the destination path of the copy is relative to the workspace root.</li> </ul>"},{"location":"guide/fs/#creating_a_symlink","title":"Creating a symlink","text":"<p>The above method works fine if the file does not change too often - if not, you may want to create a symbolic link instead:</p> <pre><code>repos:\n  - dest: project_1\n    url: git@acme.com:team/project_1\n\n  - dest: project_2\n    url: git@acme.com:team/project_2\n\n  - dest: common\n    url: git@acme.com:team/commont\n    symlink:\n    - source: .clang-format\n      target: common/clang-format\n</code></pre> <pre><code>$ tsrc sync\n=&gt; Cloning missing repos\n...\n=&gt; Performing filesystem operations\n* (1/1) Lint /path/to/work/.clang-format -&gt; common/.clang-format\n</code></pre> <p>Notes:</p> <ul> <li> <p>The source path for a symbolic link is relative to the top-level <code>&lt;workspace&gt;</code>, whereas   each target path is then relative to the associated source.  (This path relationship   is essentially identical to how <code>ln -s</code> works on the command line in Unix-like   environments.)  Multiple symlinks can be specified; each must specify a source and target.</p> </li> <li> <p>Symlink creation is supported on all operating systems, but creation of NTFS symlinks on   Windows requires that the current user have appropriate security policy permission   (SeCreateSymbolicLinkPrivilege).  By default, only administrators have that privilege set,   although newer versions of Windows 10 support a Developer Mode that permits unprivileged   accounts to create symlinks.  Note that Cygwin running on Windows defaults to creating   links via Windows shortcuts, which do not require any special privileges.   (Cygwin's symlink behavior can be user controlled with the <code>winsymlinks</code> setting   in the <code>CYGWIN</code> environment variable.)</p> </li> </ul>"},{"location":"guide/groups/","title":"Using groups","text":"<p>Sometimes it can be necessary to create groups of repositories, especially if the number of repositories grows and if you have people in different teams work on different repositories.</p>"},{"location":"guide/groups/#defining_groups_in_the_manifest","title":"Defining groups in the manifest","text":"<p>The first step is to edit the <code>manifest.yml</code> file to describe the groups. Here's an example.</p> <pre><code>repos:\n  - {url: git@gitlab.local:acme/one,   dest: one}\n  - {url: git@gitlab.local:acme/two,   dest: two}\n  - {url: git@gitlab.local:acme/three, dest: three}\n\ngroups:\n  default:\n    repos: []\n  g1:\n    repos:\n      - one\n      - two\n  g2:\n    repos:\n      - three\n</code></pre> <p>Here we define a <code>g1</code> group that contains repositories named <code>one</code> and <code>two</code>, and a <code>g2</code> group that contains the repository named <code>three</code>.</p>"},{"location":"guide/groups/#using_groups_in_tsrc_init","title":"Using groups in <code>tsrc init</code>","text":"<p>If you only need the repositories in the <code>g1</code> group you can run:</p> <pre><code>tsrc init git@gitlab.local:acme/manifest --group g1\n</code></pre>"},{"location":"guide/groups/#filtering_repositories_in_groups_with_regular_expressions","title":"Filtering repositories in groups with regular expressions","text":"<p>You can utilize inclusive regular expression with the <code>-r</code>-flag and exclusive regular expression with the <code>-i</code>-flag. This allows you to filter repositories within a group or a set of groups for the given action.</p> <p>To include all repositories in the group g1 matching \"config\" and excluding \"template\", you can do the following:</p> <pre><code>tsrc init git@gitlab.local:acme/manifest --group g1 -r config -i template\n</code></pre>"},{"location":"guide/groups/#updating_workspace_configuration","title":"Updating workspace configuration","text":"<p>Alternatively, you can edit the <code>.tsrc/config.yml</code> file, like this:</p> <pre><code>manifest_url: git@gitlab.local:acme/manifest.git\nmanifest_branch: master\nrepo_groups:\n- g1   # &lt;- specify the list of groups to use\n</code></pre> <p>You can use this technique to change the groups used in a given workspace - the above method using <code>init</code> only works to create new workspaces.</p> <p>The config file contains other configuration options, which are described in the workspace configuration documentation.</p>"},{"location":"guide/manifest/","title":"Editing the manifest safely","text":""},{"location":"guide/manifest/#introduction_when_things_go_wrong","title":"Introduction: when things go wrong","text":"<p>Let's assume you've successfully implemented <code>tsrc</code> for your organization - now need to make sure to not break anyone's workflow.</p> <p>Let's see what could go wrong if you make mistakes while editing the manifest, using a branch called <code>broken</code> for the sake of the example).</p> <p>First, let's see what happens if you break the YAML syntax:</p> <pre><code>commit 1633c5a6 (HEAD -&gt; broken, origin/broken)\n\n    Break the manifest syntax\n\ndiff --git a/manifest.yml b/manifest.yml\nindex fe74142..068c35e 100644\n--- a/manifest.yml\n+++ b/manifest.yml\n@@ -1,4 +1,4 @@\n-repos:\n+repos\n   - url: git@github.com:your-tools/bar.git\n     dest: bar\n</code></pre> <p>After this change is push,  anyone using the <code>broken</code> branch of the manifest will be faced with this kind of error message:</p> <pre><code>$ tsrc sync\n</code></pre> <pre><code>=&gt; Updating manifest\nReset branch 'broken'\nYour branch is up to date with 'origin/broken'.\nBranch 'broken' set up to track remote branch 'broken' from 'origin'.\nHEAD is now at 1633c5a Break the manifest syntax\nError: /path/to/work/.tsrc/manifest/manifest.yml: mapping values are\nnot allowed here :\n\n      - url: git@gitlab.acme.com:your-team/foo\n           ^ (line: 2)\n</code></pre> <p>Similarly, if you put an invalid URL in the manifest, like this:</p> <pre><code>commit ccfb902 (HEAD -&gt; broken, origin/broken)\n\n    Use invalid URL for bar repo\n\ndiff --git a/manifest.yml b/manifest.yml\nindex fe74142..068c35e 100644\n--- a/manifest.yml\n+++ b/manifest.yml\n@@ -1,4 +1,4 @@\nrepos:\n-  - url: git@gitlab.acme.com:your-team/bar\n+  - url: git@gitlab.acme.com:your-team/invalid\n     dest: bar\n</code></pre> <p>Users will get:</p> <pre><code>$ tsrc sync\n</code></pre> <pre><code>:: Using workspace in /path/to/work\n=&gt; Updating manifest\n...\nHEAD is now at ccfb902 Use invalid URL\n=&gt; Cloning missing repos\n=&gt; Configuring remotes\n* bar: Update remote origin to new url: (git@acme.com:your-team/invalid.git)\n...\n=&gt; Synchronizing repos\n* (1/2) Synchronizing bar\n* Fetching origin\nERROR: Repository not found.\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nError: fetch from 'origin' failed\n* (2/2) Synchronizing foo\n ...\nError: Failed to synchronize the following repos:\n* bar : fetch from 'origin' failed\n</code></pre> <p>This will probably not be a huge problem for you, dear reader, because you know about tsrc's manifest and its syntax.</p> <p>It will, however, be a problem for people who are just using <code>tsrc</code> without knowledge of how it is implemented, because those error messages will definitely confuse them.</p>"},{"location":"guide/manifest/#using_the_apply-manifest_command_to_avoid_breaking_developers_workflow","title":"Using the apply-manifest command to avoid breaking developers workflow","text":"<p>If you have a file on your machine containing the manifest changes, you can use <code>tsrc apply-manifest</code> to check those changes against your own workspace:</p> <pre><code>$ cd /path/to/work\n$ tsrc apply-manifest /path/to/manifest-repo/manifest.yml\n# Check that the changes are OK\n# If so, commit and push manifest changes:\n$ cd path/to/manifest-repo\n$ git commit -a -m \"...\"\n$ git push\n# Now you know that everyone can safely run `tsrc sync`\n</code></pre>"},{"location":"guide/manifest/#additional_notes","title":"Additional notes","text":"<ul> <li> <p>It is not advised to edit the file in   <code>.tsrc/manifest/manifest.yml</code> directly, because <code>tsrc sync</code> will   silently undo any local changes made to this file. This is a known bug,   see #279 for details.</p> </li> <li> <p>It is common to place the manifest repo itself in the manifest - so it's easy to edit or read:</p> </li> </ul> <pre><code># In acme.com:your-team/manifest - manifest.yml\nrepos:\n  - url: git@acme.com:your-team/manifest\n     dest: manifest\n\n  - url: git@acme.com:your-team/foo\n     dest: foo\n\n  - url: git@acme.com:your-team/bar\n     dest: bar\n</code></pre> <p>In that case, you would use:</p> <pre><code>$ tsrc apply-manifest &lt;workspace&gt;/manifest/manifest.yml\n</code></pre> <p>to check changes before pushing them.</p>"},{"location":"guide/remotes/","title":"Using several remotes","text":"<p>When you specify a repository in the manifest with just an URL, <code>tsrc</code> assumes you want a remote named origin:</p> <pre><code>repos:\n  - dest: foo\n    url: git@gitlab.acme.com/your-team/foo\n\n  - dest: bar\n    url: git@gitlab.acme.com/your-team/bar\n</code></pre> <p>But sometimes you need several remotes. Let's see a few use cases.</p>"},{"location":"guide/remotes/#mirroring_open-source_projects","title":"Mirroring open-source projects","text":"<p>If you want some repos in your organization to be open source, you may need:</p> <ul> <li>a remote named 'origin' containing for the private repository on your GitLab instance</li> <li>a remote named 'github' for the public repository on GitHub</li> </ul> <p>In that case, you can use an alternative syntax:</p> <pre><code>repos:\n  # foo is open source and thus needs two remotes:\n  - dest: foo\n  - remotes:\n    - name: origin\n      url: git@gitlab.acme.com/your-team/foo\n    - name: github\n      url: git@github.com/your-team/foo\n\n  # bar is closed source and thus only needs the\n  # default, 'origin' remote:\n  - dest: bar\n    url: gitlab.acme.com/your-team/bar\n</code></pre> <p>After this change, when running <code>tsrc init</code> or <code>tsrc sync</code>, both the <code>origin</code> and <code>github</code> remotes will be created in the <code>foo</code> repo if they don't exist, and both remotes will be fetched when using <code>tsrc sync</code>.</p>"},{"location":"guide/remotes/#using_a_vpn","title":"Using a VPN","text":"<p>Sometimes you will need two remotes, because depending the physical location of your developers, they need to use either:</p> <ul> <li>a 'normal' remote, when they are in the office</li> <li>a 'vpn' remote, when they are working at home</li> </ul> <p>In that case, you can create a manifest looking like this:</p> <pre><code>repos:\n  - dest: foo\n  - remotes:\n    - name: origin\n      url: git@gitlab.local/your-team/foo\n    - name: vpn\n      url: git@myvpn.com/gitlab/your-team/foo\n\n  - dest: bar\n  - remotes:\n    - name: origin\n      url: git@gitlab.local/your-team/bar\n    - name: vpn\n      url: git@myvpn.com/gitlab/your-team/bar\n</code></pre> <p>Developers can then use the <code>-r, --singular-remote</code> option to either use the <code>origin</code> or <code>vpn</code> when running <code>tsrc init</code> (to create a workspace), or <code>tsrc sync</code> (to synchronize it), depending on their physical location:</p> <pre><code># Init the workspace using the 'vpn' remote\n$ tsrc init -r vpn\n# Bring back the computer in the office\n# Synchronize using the 'origin' remote:\n$ tsrc sync -r origin\n</code></pre> <p>Note</p> <p>When using this option, <code>tsrc</code> expects the remote to be present in the manifest for all repositories.</p>"},{"location":"guide/workspace-config/","title":"Editing workspace configuration","text":""},{"location":"guide/workspace-config/#creation","title":"Creation","text":"<p>The configuration file created by <code>tsrc init</code> contains the whole list of available settings, with their default value, and is located at <code>&lt;/path/to/workspace/.tsrc/manifest.yml&gt;</code>.</p> <p>Note that if you use command-line options when using <code>tsrc init</code>, those will be written in the <code>.tsrc/config.yml</code>.</p> <p>For instance:</p> <pre><code>tsrc init git@github.com:dmerejkowsky/dummy-manifest\n</code></pre> <p>generates this file:</p> <pre><code>manifest_url: git@github.com:dmerejkowsky/dummy-manifest\nmanifest_branch: master\nrepo_groups: []\nshallow_clones: false\nclone_all_repos: false\nsingular_remote:\n</code></pre> <p>But</p> <pre><code>tsrc init git@github.com:dmerejkowsky/dummy-manifest --branch main\n</code></pre> <p>generates this instead:</p> <pre><code>manifest_url: git@github.com:dmerejkowsky/dummy-manifest\nmanifest_branch: main\nrepo_groups: []\nshallow_clones: false\nclone_all_repos: false\nsingular_remote:\n</code></pre>"},{"location":"guide/workspace-config/#editing","title":"Editing","text":"<p>You can edit the workspace configuration as you please, for instance if you need to switch the manifest branch.</p> <p>If you do so, note that your changes will be taken into account next time you run <code>tsrc sync</code>.</p>"},{"location":"ref/cli/","title":"Command line usage","text":""},{"location":"ref/cli/#important_note","title":"Important note","text":"<p>We use the argparse library to parse command line arguments, so the <code>--help</code> messages are always up-to-date, probably more so than this documentation :)</p>"},{"location":"ref/cli/#general","title":"General","text":"<p><code>tsrc</code> uses the same \"subcommand\" pattern as git does.</p> <p>Options common to all commands are placed right before the command name.</p> <p>Options after the command name only apply to this command.</p> <p>For instance:</p> <pre><code>$ tsrc --verbose sync\n$ tsrc init MANIFEST_URL\n</code></pre>"},{"location":"ref/cli/#goodies","title":"Goodies","text":"<p>First, note that like <code>git</code>, tsrc will walk up the folders hierarchy looking for a <code>.tsrc</code> folder, which means you can run tsrc commands anywhere in your workspace, not just at the top.</p> <p>Second, almost all commands run the operation in parallel. For instance, <code>tsrc sync</code> by default will use as many jobs as the number of CPUs available on the current machine to synchronize the repos in your workspace. If this behavior is not desired, you can specify a greater (or lower) number of jobs using something like <code>tsrc sync -j2</code>, or disable the parallelism completely with <code>-j1</code>. You can also set the default number of jobs by using  the <code>TSRC_PARALLEL_JOBS</code> environment variable.</p>"},{"location":"ref/cli/#global_options","title":"Global options","text":"--verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal)"},{"location":"ref/cli/#usage","title":"Usage","text":"tsrc init MANIFEST_URL [--group GROUP1, GROUP2] [--singular-remote SINGULAR_REMOTE] <p>Initializes a new workspace.</p> <p>MANIFEST_URL should be a git URL containing a valid <code>manifest.yml</code> file.</p> <p>The <code>-g,--groups</code>  option can be used to specify a list of groups to use when cloning repositories.</p> <p>The <code>-r</code> \"inclusive regular expression\" and <code>-i</code> \"exclusive regular expression\" options can be combined with the group option to filter for repositories within a group. <code>-r</code> takes precedence if both options are present.</p> <p>The <code>-s,--shallow</code> option can be used to make shallow clone of all repositories.</p> <p>If you want to add or remove a group in your workspace, you can edit the configuration file in <code>&lt;workspace&gt;/.tsrc/config.yml</code></p> <p>The <code>-r,--singular-remote</code> option can be used to set a fixed remote to use when cloning and syncing the repositories. If this flag is set, the remote from the manifest with the given name will be used for all repos. It is an error if a repo does not have this remote specified.</p> tsrc foreach -- command --opt1 arg1 <p>Runs <code>command --opt1 arg1</code> in every repository, and report failures at the end.</p> <p>Note the <code>--</code> token to separate options for <code>command</code> from options for <code>tsrc</code>.</p> tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell (<code>/bin/sh</code> on Linux or macOS, <code>cmd.exe</code> on Windows). tsrc log --from FROM [--to TO] <p>Display a summary of all changes since <code>FROM</code> (should be a tag), to <code>TO</code> (defaulting to <code>master</code>).</p> <p>Note that if no changes are found, the repository will not be displayed at all.</p> tsrc status <p>Displays a summary of the status of your workspace:</p> <ul> <li>Shows dirty repositories</li> <li>Shows repositories not on the expected branch</li> </ul> tsrc sync [--correct-branch/-c] Updates all the repositories and shows a summary at the end. If any of the repositories is not on the configured branch, but it is clean and the <code>--correct-branch</code>/<code>-c</code> flag is set, then the branch is changed to the configured one and then the repository is updated. Otherwise that repository will not be not updated. tsrc version Displays <code>tsrc</code> version number, along additional data if run from a git clone. tsrc apply-manifest PATH Apply changes from the manifest file located at <code>PATH</code>. Useful to check changes in the manifest before publishing them to the manifest repository."},{"location":"ref/manifest-config/","title":"Manifest configuration","text":"<p>The manifest configuration must be stored in a file named <code>manifest.yml</code>, using YAML syntax.</p> <p>It is always parsed as a mapping. Here's an example:</p> <pre><code>repos:\n  - url: git@gitlab.local:proj1/foo\n    dest: foo\n    branch: next\n\n  - remotes:\n      - name: origin\n        url: git@gitlab.local:proj1/bar\n      - name: upstream\n        url: git@github.com:user/bar\n    dest: bar\n    branch: master\n    sha1: ad2b68539c78e749a372414165acdf2a1bb68203\n\n  - url: git@gitlab.local:proj1/app\n    dest: app\n    tag: v0.1\n    copy:\n      - file: top.cmake\n        dest: CMakeLists.txt\n      - file: .clangformat\n    symlink:\n      - source: app/some_file\n        target: ../foo/some_file\n</code></pre> <p>In this example:</p> <ul> <li>First, <code>proj1/foo</code> will be cloned into <code>&lt;workspace&gt;/foo</code> using the <code>next</code> branch.</li> <li>Then, <code>proj1/bar</code> will be cloned into <code>&lt;workspace&gt;/bar</code> using the <code>master</code> branch, and reset to <code>ad2b68539c78e749a372414165acdf2a1bb68203</code>.</li> <li>Finally:<ul> <li><code>proj1/app</code> will be cloned into <code>&lt;workspace&gt;/app</code> using the <code>v0.1</code> tag,</li> <li><code>top.cmake</code> will be copied from <code>proj1/app/top.cmake</code> to <code>&lt;workspace&gt;/CMakeLists.txt</code>,</li> <li><code>.clang-format</code> will be copied from <code>proj1/app/</code> to <code>&lt;workspace&gt;/</code>, and</li> <li>a symlink will be created from <code>&lt;workspace&gt;/app/some_file</code> to <code>&lt;workspace&gt;/foo/some_file</code>.</li> </ul> </li> </ul>"},{"location":"ref/manifest-config/#top_fields","title":"Top fields","text":"<ul> <li><code>repos</code> (required): list of repositories to clone</li> <li><code>groups</code> (optional): list of groups</li> </ul>"},{"location":"ref/manifest-config/#repos","title":"repos","text":"<p>Each repository is also a mapping, containing:</p> <ul> <li>Either:<ul> <li><code>url</code> if you just need one remote named <code>origin</code></li> <li>A list of remotes with a <code>name</code> and <code>url</code>. In that case, the first remote   will be used for cloning the repository.</li> </ul> </li> <li><code>dest</code> (required): relative path of the repository in the workspace</li> <li><code>branch</code> (optional): The branch to use when cloning the repository (defaults   to <code>master</code>)</li> <li><code>tag</code> (optional):<ul> <li>When running <code>tsrc init</code>: Project will be cloned at the provided tag.</li> <li>When running <code>tsrc sync</code>:  If the project is clean, project will be reset to the given tag, else a warning message will be printed.</li> </ul> </li> <li><code>sha1</code> (optional):<ul> <li>When running <code>tsrc init</code>: Project will be cloned, and then reset to the given sha1.</li> <li>When running <code>tsrc sync</code>:  If the project is clean, project will be reset to the given sha1, else a warning message will be printed.</li> </ul> </li> <li><code>ignore_submodules</code> (optional, default=<code>false</code>):<ul> <li>When running <code>tsrc init</code>: if <code>ignore_submodules</code> is <code>true</code>, do not recursively clone submodules.</li> <li>When running <code>tsrc sync</code>: if <code>ignore_submodules</code> is <code>true</code>, do not initialize or update submodules. to the given sha1, else a warning message will be printed.</li> </ul> </li> <li><code>copy</code> (optional): A list of mappings with <code>file</code> and <code>dest</code> keys.</li> <li><code>symlink</code> (optional): A list of mappings with <code>source</code> and <code>target</code> keys.</li> </ul> <p>See the Using fixed references and the Performing file system operations guides for details about how and why you would use the <code>tag</code>, <code>sha1</code>, <code>copy</code> or <code>symlink</code> fields.</p>"},{"location":"ref/manifest-config/#groups","title":"groups","text":"<p>The <code>groups</code> section lists the groups by name. Each group should have a <code>repos</code> field containing a list of repositories (only repositories defined in the <code>repos</code> section are allowed).</p> <p>The groups can optionally include other groups, with a <code>includes</code> field which should be a list of existing group names.</p> <p>The group named <code>default</code>, if it exists, will be used to know which repositories to clone when using <code>tsrc init</code> and the <code>--group</code> command line argument is not used.</p> <p>Example:</p> <pre><code>repos:\n  - dest: a\n    url: ..\n  - dest: b\n    url: ..\n  - dest: bar\n    url: ..\n  - dest: baz\n    url: ..\n\ngroups:\n  default:\n    repos: [a, b]\n  foo:\n    repos: [bar, baz]\n    includes: [default]\n</code></pre> <pre><code>$ tsrc init &lt;manifest_url&gt;\n# Clones a, b\n$ tsrc init &lt;manifest_url&gt; --group foo\n# Clones a, b, bar and baz\n</code></pre> <p>Note that <code>tsrc init</code> records the names of the groups it was invoked with, so that <code>tsrc sync</code> re-uses them later on. This means that if you want to change the groups used, you must re-run <code>tsrc init</code> with the new group list.</p> <p>Note</p> <p>More information about how to use groups is available in the relevant guide.</p>"},{"location":"ref/sync/","title":"Sync algorithm","text":"<p>You may have noticed that <code>tsrc sync</code> does not just calls <code>git pull</code> on every repository.</p> <p>Here's the algorithm that is used:</p> <ul> <li>Run <code>git fetch --tags --prune</code></li> <li>Check if the repository is on a branch</li> <li>Check if the currently checked out branch matches the one configured in   the manifest. If it does not but the <code>--correct-branch</code> flag is set   and the repository is clean, the branch is changed to the configured one. </li> <li>Check if the repository is dirty</li> <li>Try and run a fast-forward merge</li> </ul> <p>Note that:</p> <ul> <li><code>git fetch</code> is always called so that local refs are up-to-date</li> <li><code>tsrc</code> will simply print an error and move on to the next repository if the   fast-forward merge is not possible. That's because <code>tsrc</code> cannot guess   what the correct action is, so it prefers doing nothing. It's up   to the user to run something like <code>git merge</code> or <code>git rebase</code>.</li> <li>in case the repository is on an incorrect branch, the fast-forward merge will   still be attempted, but an error message will be show in the end</li> </ul>"},{"location":"ref/workspace-config/","title":"Workspace configuration","text":"<p>The workspace configuration lies in <code>&lt;workspace&gt;/.tsrc/config.yml</code>.  It is created by <code>tsrc init</code> then read by <code>tsrc sync</code> and other commands. It can be freely edited by hand.</p> <p>Here's an example:</p> <pre><code>manifest_url: git@acme.corp:manifest.git\nmanifest_branch: master\nshallow_clones: false\nrepo_groups:\n- default\nclone_all_repos: false\nsingular_remote:\n</code></pre> <ul> <li><code>manifest_url</code>: an git URL containing a <code>manifest.yml</code> file</li> <li><code>manifest_branch</code>: the branch to use when updating the local manifest (e.g, the first step of <code>tsrc sync</code>)</li> <li><code>shallow_clones</code>: whether to use only shallow clones when cloning missing repositories</li> <li><code>repo_groups</code>: the list of groups to use - every mentioned group must be present in the <code>manifest.yml</code> file (see above)</li> <li><code>clone_all_repos</code>: whether to ignore groups entirely and clone every repository from the manifest instead</li> <li><code>singular_remote</code>: if set to <code>&lt;remote-name&gt;</code>, behaves as if <code>tsrc sync</code> and <code>tsrc init</code> were called with <code>--singular-remote &lt;remote-name&gt;</code> option. See the Using remotes guide for details.</li> </ul>"}]}